**************** Orientação a Objetos ****************

--------- Modificadores de Acesso ---------

Private -> A única classe que tem acesso ao atributo é a própria classe que o define, ou seja, se uma classe Pessoa declara um atributo privado chamado nome, somente a classe Pessoa terá acesso a ele.

Protected -> A Própria Classe, seus Pacotes, e suas SubClasses tem acesso.

Public -> Todos tem acesso.

--------- Metodos Acessores (Getters E Setters) ---------

Getter -> Somente lê o valor da propriedade.

Setter -> Modifica o valor da propriedade.

--------- ENCAPSULAMENTO ---------

Em ES6 nós encapsulamos objetos utilizando 

Object.freeze(obj);

isso faz com que o usuário ou programador, não consiga alterar o valor da propriedade daquele objeto.

POREM, essa solução funciona apenas para objetos shallow(razo), [DEFINIÇÃO SHALLOW E DEEP ABAIXO], caso o objeto for deep(profundo), essa solução não funcionará.

-- OBJETOS SHALLOW --

São objetos que não possuem metodos modificadores, que não possuem algum metodo que possa comprometer sua estrutura.

-- OBJETOS DEEP --

São objetos que já possuem metodos modificadores e etc.

--------- Quando devo instanciar uma Classe? ---------

-- Instânciada --

    Classe que DEVE ser instânciada são classes que NÃO são estáticas.

-- Não instanciada --

    Classe que não precisa de INSTANCIA são classes ESTÁTICAS.
    
**************** Regra de Negocio ****************

Toda empresa tem sua regra de negócio, e devemos implementar essa regra no código.

Exemplo: na minha Classe Negociacao, eu tenho uma regra de negocio.

1° Regra: Toda negocião após concluída, não pode ser alterada.

**************** ES6 EcmaScript6 ****************

--------- Diferença entre VAR E LET ---------

var -> não possui escopo de bloco possui escopo de FUNÇÃO, 
    tudo que for atribuido dentro de um escopo de bloco, pode ser exibido fora do bloco, e tambem podemos sobrescrever variáveis(oq não é bom)

let -> possui escopo de BLOCO, não deixa sobrescrever variáveis já declaradas, 
    apenas atribuir um novo valor a ela ( RECOMENDADA USAR APENAS EM BLOCOS, FORA DE BLOCOS USAR VAR)

const -> variaveis declaradas como const tem seu valor fixo, não podendo ser alterado, 
    a menos que a variavel seja um new Date por exemplo, que eu posso modificalá atraves de seus metodos.

Exemplo das diferenças:

-- Com var --

    for(var i = 0; i <= 100; i++){
        var nome = "Nicolas";
    }
    console.log(i) // irá exibir 101
    console.log(nome) // irá exibir Nicolas
    
-- Com let --

    for(let i = 0; i <= 100; i++){
        let nome = "Nicolas";
    }
    console.log(i) // irá exibir i is not defined
    console.log(nome) // irá exibir nome is not defined
    
Porque aparece isso com let? justamente pq let funciona por escopo de BLOCO.

--- indexedDB ---

** Dexie e o Db.js libs de indexedDB **

IMPORTANTE!
o onupgradeneeded, só sera executado novamente ( depois da primeira vez ) quando a versao do banco for maior que a atual, isso é.. tem que mudar em .open('nomeBanco', 'numeroVersaoConexao');

Primeiro abrir a requisicao
    var request = window.indexedDB.open('nomeBanco', 1);

// Cria ou altera um banco existente
request.onupgradeneeded = (e){

    console.log("Cria ou altera um banco existente");
}

// Verifica se a conexao foi obtida
request.onsuccess= (e) => {

    console.log("Conexão obtida com sucesso");
}

// Verifica se a conexao deu erro
request.onerror = (e) => {

    // para descobrir o tipo de erro que aconteceu
    console.log(e.target.error);
}

Agora precisamos de uma instancia de IDBDatabase ou seja, uma conexao.

criamos uma variavel connection com escopo global.. e lá no retorno da funcao onsucess, adicionamos ela recebendo o parametro e.target.result, que retornara nossa IDBDatabase

Exemplo: 
    var connection;
        
    //Abre a requisicao
    var request = window.indexedDB.open('aluraframe', numeroDaVersao); // O numero da versao deve ser alterado toda vez que voce necessite que onupgradeneeded seja chamado, em casos como.. criar o banco... criar uma objectStore...

    request.onupgradeneeded = (e) => {

        console.log("Cria ou altera um banco existente");
    }

    request.onsuccess= (e) => {

        console.log("Conexão obtida com sucesso");
        console.log(e.target.result);

        connection = e.target.result;
    }

    request.onerror = (e) => {

        // para descobrir o tipo de erro que aconteceu
        console.log(e.target.error);
    }

Bom.. agora que já temos nossa conexao feita, precisamos criar nosso objectStore, porem.. para criar um objectStore, devemos criar uma conexao em onupgradeneeded, pois é lá que é verificado se existe alguma atualizacao..

entao fazemos o seguinte:
    request.onupgradeneeded = (e) => {

        console.log("Cria ou altera um banco existente");

        var minhaConexao = e.target.result;
        minhaConexao.createObjectStore('nomeDoArmazenamento');
    }
    
Agora precisamos de uma transaction, para poder gravar dentro da objectStore, primeiro pegamos a transaction, e apos isso acessamos passando qual objectStore nós queremos utilizar, e atravez do store, eu posso incluir alterar listar e etc.., entao... criamos uma negociacao, e adicionamos no store indicado com o metodo .add passando a negociacao a ser adicionada nesse caso, porem todo .add retona um onsuccess ou onerror, pois nem sempre vai ter sucesso em adicionar algo, pode ser q de erro.

function adiciona(){
            
            // Precisamos de uma transacao para poder gravar dentro da objectStore
            //Crio uma transacao
            let transaction = connection.transaction(['negociacoes'], 'readwrite');
            //Aponto para qual objectStore eu quero acessar.
            let store = transaction.objectStore('negociacoes');
            // crio uma negociacao de teste
            let negociacao = new Negociacao(new Date(), 1, 200);
            // peco para adicionar minha negociacao ao store
            let request = store.add(negociacao);
            
            // objetoQueRecebeTransacao, exemplo: negociacoes
            // tipoTransacao = readyonly(apenas leitura) readwrite(leitura e escrita);
        }

-- Listar no indexedDB --

    function listaTodos(){
                
        // Precisamos de uma transacao para poder gravar dentro da objectStore
        //Crio uma transacao
        let transaction = connection.transaction(['negociacoes'], 'readwrite');
        //Aponto para qual objectStore eu quero acessar.
        let store = transaction.objectStore('negociacoes');
        
        // ele aponta para cada linha da nossa objectSore, esse é o cara que vai 'passear'por la
        let cursor = store.openCursor();
        
        let negociacoes = [];
        
        cursor.onsuccess = e => {
            //Recebe o ponteiro
            let atual = e.target.result;
            // Se tiver um ponteiro valido
            if(atual){
                // recebo o valor do ponteiro, apenas as propriedades q recebo
                let dado = atual.value;
                
                negociacoes.push(new Negociacao(dado._data, dado._quantidade, dado._valor));
                // Pedindo para o indexedDB ir para a proxima negociacao,
                //Quando chamamos o continue, ele chama o metodo onsuccess novamente, e assim ele vai dar esse loop ate n ter mais dado para apontar
                atual.continue();
            }else{
                console.log(negociacoes);
            }
        }
        
        cursor.onerror = e => {
            console.log(e.target.error.name);
        } 
    }

-- APAGAR no indexedDB --

apagaTodos(){
        
    return new Promise((resolve, reject) => {

        let request = this._connection
            .transaction([this._store], 'readwrite')
            .objectStore(this._store)
            .clear();
        
        request.onsuccess = e => resolve(`Negociações apagadas com sucesso.`);

        request.onerror = e => {

            console.log(e.target.error);
            reject(`Erro ao apagar negociações`)
        }

    });
}

--------- Fetch API ---------

Simplificando a maneira de fazer requisições AJAX.
A Fetch API só me devolve a requisição, SOMENTE se o readyState dela for 4, isso é, se todo o processo foi feito.

.fetch(url) -> url de GET
.then(res) -> retorna uma resposta da requisicao q foi feita, posso transformar a resposta em
    json com .json(), em texto com .text().

Exemplo de GET e POST:

-- GET --

    return fetch(url)
            .then(res => this._handlerError(res))
            .then(res => res.json()); // converto o dado de string para JSON
-- POST --

    return fetch(url, {
        headers: {'Content-type': 'application/json'},
        method: 'post',
        body: JSON.stringify(dado) // envio  o dado como string para post
    })
    .then(res => this._handlerError(res));

--------- Transpiler (transcompilador) ---------

    Nós programaremos com o ES6 e depois, vamos compilar o código para o ES5.
    Este processo de downgrade recebe o nome de transcompilação e é feito com o uso de um transpiler (transcompilador).

    Babel e TypeScript já fazem o uso de transpilers.

---- Como Instalar o babel? ----
    De esse comando na pasta raiz do projeto
        npm install babel-cli@6.10.1 --save-dev 
            Esse --save-dev é para salvar a dependencia(babel-cli@6.10.1) do babel, no seu package.json