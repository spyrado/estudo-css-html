**************************** JAVA ****************************

------------ O que é JVM? O que é JDK? / O que é JRE? ------------

JVM - Java Virtual Machine -> É ela que faz o processo de identificar o bytecode (codigo java), e traduzir eles
    para diversos tipos de Sistemas Operacionais.

JDK -> Java Development Kit ( Kit de Desenvolvimento Java ), precisamos dele pois ele que contem a JVM, as libs, 
    o compilador.

JRE -> O JRE é o ambiente para executar uma aplicação Java, que vem com a virtual machine e as bibliotecas.

o JRE e JDK. O primeiro é o ambiente de execução, o segundo são as ferramentas de desenvolvimento 
    junto com o ambiente de execução

JDK = JRE + ferramentas desenvolvimento

JRE = JVM + bibliotecas


------------ Tipos de Variaveis ------------

int -> aceita numeros inteiros (10,5,0,20)
long -> para long devemos terminar com l no final, seja ele minusculo ou maiusculo:
    long num = 2131627316262137L OU long num = 2131627316262137l

--- Tipo Flutuante ---
double -> aceita numeros com restos (10.5, 5.5, 0.0, 20.0)
float -> float num = 3.14; // vai dar um erro, temos q fazer casting para float OU colocar um f no final:
    float num = 3.14f; OU float num = (float) 3.14;

------------ Tipos e seus bits ------------

byte = 1 byte - 8 bits = -128-127 - números inteiros
short = 2 bytes - 16 bits = -32768 a +32767 - números inteiros
int = 4 bytes - 32 bits = -2147483648 a + 2147483647 - números inteiros
long = 8 bytes - 64 bits = -922337203685477808 a 922337203685477807 - números inteiros
float = 4 bytes - 32 bits = aproximadamente 3.40282347E+38 = Ponto flutuante
double = 8bytes - 64 bits = 1.79769313486231570W+308 = Ponto Flutuante
chart = Caracteres Unicode 16 bits = 0 a 65536 = caracteres
booleann = Possuem valores True e false = booleano

------------ Peculiaridades de tipos flutuantes ------------

Se eu faço uma conta de um tipo double como essa:

double divisao = 5/2; // 2
double divisao = 5.0/2; // 2.5

porque da resultado diferente? pq o compilador primeiro executa a conta, e depois verifica o tipo..
então se colocarmos um numero do tipo flutuante, ele já vai identificar que tem que fazer a conta com base
no tipo double(como nesse exemplo), e ai o resultado muda.


------------ Orientacao a Objetos ------------

---- Referencia ----

    Conta nicolas = new Conta(); // bytebank.Conta@33909752
    Uma instancia não é um Objeto do tipo Conta, ele é apenas uma Referencia(bytebank.Conta@33909752) para o Objeto do tipo Conta.

    tanto isso é verdade que se fizermos isso:
        joyce = nicolas; // bytebank.Conta@33909752

    joyce n tera um NOVO Objeto do tipo Conta.., joyce agora... passa a ter uma Referencia(bytebank.Conta@33909752) para
    a MESMA Conta que nicolas acessava, pois ambos vao possuir a mesma Referencia para a conta.

    tanto isso é verdade2, que se eu definir um saldo para joyce, o nicolas vai ter o MESMO saldo, pois ambos tem a mesma
        Referencia(bytebank.Conta@33909752) de conta.

    joyce.saldo = 5000; // 5000
    nicolas.saldo // 5000

---- Objeto ----

    O Java por padrao inicializa seus objetos com 0,
        EXEMPLO:
            double saldo;
            int agencia;
            int numero;
            String titular;

    Quando for acessar da main:
        Conta nicolas = new Conta();
        nicolas.saldo // 0 -> ele exibe 0, pois por default ele inicializa com 0
        nicolas.titular // null -> pois n tem nada.

---- Atributo static ----

O static faz com que o atributo seja da classe, e não mais do objeto. Com isso, todo o objeto conta 
    possui acesso a um único total.

private static int total; -> estou falando que o total n vai variar de classe pra classe, o total será um valor fixo..
    entao se vc der new em uma classe q contem o total, o valor dele vai continuar o mesmo..

---- Metodos static ----

    Metodos estaticos somente iram acessar atributos estaticos da classe, ele n aceita refenrecia para o objeto(this)


---- Modificadores de acesso ----

public -> visivel a todos
private -> Somente a propria classe pode ver
protected -> A propria classe E seus filhos também podem ver.

---- SOBRECARGA DE METODOS ----

    public boolean autentica(int senha) {
        if(this.senha == senha) {
            return true;
        } else {
            return false;
        }
    }

    //novo método, recebendo dois params
    public boolean autentica(String login, int senha) {
        //implementacao omitida
    }

---- GENERICS / POLIMORFISMO ----

Funcionario nico = new Gerente();

Isso funciona, a classe Funcionario é do tipo mais generica, todo Gerente é um funcionario, 
    mas NEM todo funcionario é um gerente

---- POLIMORFISMO ----

    IMPORTANTE: Caso a classe Funcionario N TIVESSE O METODO getBonificacao nada abaixo seria possivel..

    //MAIN
    Gerente gerente = new Gerente();
    gerente.setSalario(5000);
    
    Funcionario funcionario = new Funcionario();
    funcionario.setSalario(2000);
    
    EditorVideo editorDeVideo = new EditorVideo();
    editorDeVideo.setSalario(2500);
    
    ControleBonificacao controle = new ControleBonificacao();
    
    controle.registra(gerente);
    controle.registra(funcionario);
    controle.registra(editorDeVideo);

    //ControleBonificacao.java
    public void registra(Funcionario funcionario) {
		double bonificacao = funcionario.getBonificacao();
		this.soma += bonificacao;
	}

    para cada tipo de funcionario registrado, ele vai até a classe do funcionario registrado, e verifica o metodo particular
    de cada um( getBonificacao() ).

    ---- A anotação @Override ----

    Se tirassemos o @Override do código abaixo, ele ainda compilaria, porem.. se errarmos o nome do metodo
    e escrever sacar.. a classe ia considerar como um NOVO metodo, e NAO uma sobrescrita da classe PAI.
    a anotacao @Override corrige isso, caso escreva sacar o @Override indica que esse metodo n existe na classe
    PAI.

    @Override
	public boolean saca(double valor) {
		double valorASacar = valor + 0.2;
		if(super.saca(valorASacar)) {
			
		}
		return super.saca(valor);
	}

---- CLASSES ABSTRATAS ----

    CLASSES ABSTRATAS NÃO SÃO OBRIGADAS A IMPLEMENTAREM METODOS ABSTRATOS DE OUTRA CLASSE ABSTRATA

---- INTERFACE ----

    Interfaces apenas utilizam metodos e nao propriedades, todos os metodos sao abstratos, exemplo:

    public abstract interface Autenticavel {
	
        public abstract boolean autentica(int senha);
        public abstract void setSenha(int senha);
    }

    RESUMO:
        Nao precisamos declarar como abstrata uma interface nem como abstrato seus metodos, pois o compilador ja entende
        que toda interface é abstrata.
        
    public interface Autenticavel {
	
        boolean autentica(int senha);
        void setSenha(int senha);
    }


---- DICAS HERANCA / POLIMORFISMO ----

    Se voce deseja reutilizar o código E fazer Polimorfismo, utilize HERANCA.
    Se voce quer apenas Polimorfismo, utilize interfaces.
    Se voce quer apenas reutilizar código utilize COMPOSIÇÃO

---- COMPOSIÇÃO ----

Podemos criar uma classe generica, para reutilizar códigos que se repetem muito, normalmente chamamos essa classe DE
algumaUtil.java e instaciamos essa classe em uma classe que necessita dos metodos dessa classe

---- COMO CRIAR UMA EXCESAO? ----

A IllegalArgumentException e IllegalStateException são duas exceções importantes, que o desenvolvedor Java deve usar. 
    Em geral, quando faz sentido, use uma exceção padrão em vez de criar uma própria.

Exceções de array ArrayIndexOutOfBounds.
    Irá disparar essa exceção caso a casa do array for negativa OU maior OU IGUAL ao tamanho do array

Para criar uma exceção, sua classe de excecao deve HERDAR da classe RuntimeException, 
    pois nela contem toda a bagagem necessária..

UNCHEKED -> Excecoes UNCHEKED basta herdar de RuntimeException que ja está funcionando.. (colocar super(msg) e etc)..

CHECKED -> Excecoes CHECKED ao herdar de Exception, voce DEVE colocar em todo metodo na assinatura dele um throw OU
    tratar o erro com try catch, exemplo:
        private static void metodo2() throws MinhaExcecao{
            
            System.out.println("Ini do metodo2");
            
            throw new MinhaExcecao("FUDEUUU AGORA EU SEI");
            
            System.out.println("Fim do metodo2");
        }

---- TRY CATCH FINALLY ----

try{ -> tenta fazer algo

}catch(Exception e){ -> se oq tendou deu algum erro ele cai aqui...

}finally{ -> independente do resultado dos dois acima.. ele vai executar esse bloco..

}

O finally é util quando abrimos uma conexao e queremos fechar ela independente se deu certo ou n ela deve ser fechada,
    e para isso usamos o finally

Podemos tambem simplificar apenas fazendo assim:

try{ -> tenta fazer algo

}finally{ -> independente do resultado acima.. ele vai executar esse bloco..

}

---- NOVO METODO TRY try-with-resources ----

Ele é mais enxuto, substitui todo o codigo citado acima(boa parte dele).

try (Conexao conexao = new Conexao()) { -> inicializa uma conexao
    conexao.leDados();
}

INTERNAMENTE vc DEVE implementar a interface AutoCloseable dentro da classe Conexao, e implementar o metodo close que essa interface
    te obriga a implementar.

Ai.. toda hora que vc abrir uma conexao.. se der ou n certo o try, ele vai executar o metodo close() implementado pela interface na classe Conexao, e é lá
que deve estar a logica necessaria para se der ou n der erro executar X coisas.

—— Pacotes ——

Imports n utilizados não geram impacto no desempenho.

 Comand shif O, faz o import de todas as dependências da classe

A nomenclatura padrão de projetos segue assim:
br.com.nomeempresa.pasta.subpasta


—— modificadores de acesso ——

<<package private>>
Ao tirar um modificador de acesso de qualquer classe,construtor,metodo,atributo, ele automaticamente vira um <<package private>>, significa que ele passa a ser visível APENAS para classes do MESMO pacote

—- Javadoc E Jar —-

Como criar um javadoc?

Como criar um jar?
Como adicionar um jar ao projeto?
Como incluir um jar no projeto?(build path)

No terminal:
 java -jar nomeDoJar.jar

Vai executar o seu jar

—— imports ——

Único pacote que vc n precisa importar para utilizar, é o java.lang

—— A Classe String ——

A Classe String é imutável, caso vc altere o comportamento dela deve atribuir esse comportamento a uma nova referência.

O java resumiu e facilitou a maneira como instanciar uma String, como o tipo String é uma classe vc teria que fazer isso aqui para instanciar uma string:

 String nome = new String(“Alura”);

O java simplificou para:

String nome = “Alura”;

Essa sintax é chamada de Objeto literal

Quando temos apenas um caracter ele é representado com aspas simples ‘’. E o tipo dele normalmente é char

—— Metodos da classe String ——

 .toUpperCase()
 .toLowerCase()
 .replace()
 .charAt()
 .indexOf()
 .substring()
 .length()
 .isEmpty()
 .trim()
 .contains()

—— Object ——

    Toda classe java implicitamente tem a Classe Object extendida, exemplo:

    public class Cliente extends Object <- se n tiver extendendo outra classe sua, o java extend o Object por padrao.

—— Arrays ——

Arrays são objetos e todo array também é tipado, para declarar um array basta fazer.
    Int[] numeros = new numeros[tamanhoVetor];

---- ArrayList ----

    ArrayList -> se vc remove um dado do ArrayList, ele vai reordenar os dados. isso tem um custo, evite fazer isso em
      processos custosos.

.add() -> adiciona no array
.remove() -> remove do array
.clear() -> remove todos as referencias do array.
.contains() -> verifica se a referencia é a mesma.
.equals() -> vem da classe Object e normalmente compara as referencias, e normalmente esse metodo é sobrescrito.

---- Vector ----

    Vector -> É util utiliza-lo somente SE tiver varias pilhas envolvidas, caso nao, use ArrayList.

---- LinkedList ----

    LinkedList -> Funciona mais o menos como ponteiros, é mais performático do que ArrayList no quesito,
        apagar dados e incluir dados em um array.

---- ArrayList LinkedList E Vector ----

    IMPORTANTE!! Todos esses arrays aceitam duplicados, oq isso significa?, significa que eu posso passar a mesma referencia,
    que ele vai adicionar a lista, e as vezes n queremos isso.

-- Array de Objetos --
    Um array de objetos sempre inicializa com NULL
    ContaCorrente[] contas = new ContaCorrente[5];

---- String[] args ----
    Para que serve esse String[] args no main?

    vc pode ir em Run as -> Run Configuration, e na aba arguments, passar os argumentos que serao executados
    quando for chamado o main.

---- GENERICS ----

Sintax de exemplo do uso de um dos tipos de generics:
    ArrayList<generics> lista = new ArrayList<generics>();

    Quero uma lista só de contas:
        ArrayList<Conta> conta = new ArrayList<Conta>();

---- HashSet ----

    Nao aceita duplicados, e tb n é uma sequencia.

---- Autoboxing ----

    Transforma um primitivo(int) em um Objeto(referencia) Integer, o Java faz isso por baixo dos panos.

    um ArrayList guarda uma lista de referencias, e como um primitivo n é um Objeto(refenrecia), o java
    na hora de passar para o ArrayList um numero por exemplo, ele faz a conversao para o Integer(Objeto/referencia)

    ArrayList<Integer> numeros = new ArrayList<Integer>();

    int num = 23;
    
    numeros.add(num);

    Se vc tirar o tipo Integer e der um .add, ele vai vir como .add(Object e).


