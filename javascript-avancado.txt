------------------------ Padroões de Projeto ------------------------

OBSERVER -> Usamos o padrão de projeto Observer sempre que queremos notificar partes do sistema interessadas quando um evento importante for disparado em nosso sistema.

No contexto da nossa aplicação, entendemos um evento como o ato de adicionar ou esvaziar nossa lista de negociações. É a view que está interessada em observar esse evento e tomar uma ação, no caso, se atualizar com base no estado mais atual do modelo.

PROXY -> FAZ A INTERMEDIAÇÃO ENTRE O OBJETO E UMA ARMADILHA, ELE PRIMEIRO EXECUTA A ARMADILHA, E DEPOIS CHAMA O OBJETO.

FACTORY -> Seria uma classe que é especializada em criar determinado tipo de objeto.
    Não é uma regra, porem geralmente classes criadas com factory utilizam metodos estáticos, para evitar ficar instanciando.

---------------------------- PROXY ----------------------------

--- IMPORTANTE ---

Metodos/Funções não são lidas com set(apenas metodos/funções que tenham propriedades a serem alteradas), apenas com get.

--- Declaração  de Proxy ---

Sintax: new Proxy(obj, handler);

let negociacao = new Proxy(Negociacao, {}); -> assim que se declara um proxy, uma vez declarado, ele tem acesso a tudo que A classe Negociacao tem.

--- HANDLER ---

{} -> passamos alguns parâmetros aqui um deles é:

--- HANDLER GET ---

TODO GET deve retornar um valor, caso não retorne, a propriedade/metodo chamada retornará o valor "undefined".

-- Valores de target, prop, receiver --:

target -> Objeto em questão.
prop -> Propriedade chamada.
receiver -> O próprio proxy.
target[prop] -> Acessando o valor da propriedade/metodo:
  Propriedade: negociacao.quantidade;
                   Retorno 2;
  Metodo: lista.adiciona(negociacao) ->
              Retorno ƒ adiciona(negociacao){
                            this._negociacoes.push(negociacao);
                        }
           
    

{
    get: function(target, prop, receiver)){
    
        return Reflect.get(target, prop, receiver); -> retorna o valor da propriedade.
    }
}

--- HANDLER SET ---

{
    set: function(obj, propriedade, value,receiver(proxy)){
    
        return Reflect.set(target, prop, value, receiver);
    }
}

--- Como definir uma armadilha? ---

this._listaNegociacoes = new Proxy(new ListaNegociacoes(),{
            
            get: function(target, prop, receiver){
                
                if(['adiciona','esvazia'].includes(prop) && typeof target[prop] == 'function'){
                    
                    return function(){
                        
                        console.log(`Interceptando ${prop}`);   
                        
                        Reflect.apply(target[prop], target, arguments);
                        self._negociacaoView.update(target); --> aqui eu aplico a armadilha
                    }
                    
                }
                
                return Reflect.get(target, prop, receiver);
            }
        });

---------------------------- API REFLECT ----------------------------

Reflect.apply(target, thisArgument, argumentsList);
Reflect.apply(soma, objNumero, []); -> ele aplica a referencia de this, no metodo/função em questão, e caso a função tenha parâmetros, colocamos em argumentsList.

Reflect.get(target, propertyKey[, receiver])
Reflect.get(objetoOuVetor, propriedadeRequirida, )


---------------------------- Reutilização de código através de mixin! ----------------------------

Reflect.apply(Aviao.prototype.voa, this, []);

Um detalhe: foi necessário fazer Aviao.prototype.voa porque métodos criados usando ES6 são adicionados no prototype. Qualquer método adicionando em prototype estará disponível para todas as instâncias.

---------------------------- COMPOSIÇÃO ----------------------------

    class Aviao {

        constructor(nome) {
            this._nome = nome;
        }

        voa() {
            alert(`${this._nome} está voando`);
        }

        ligaMotor() {
            console.log('liga o motor');
    }

    class Passarinho {

        constructor(nome) {
            this._nome = nome;
        }

        voa() {
            // hum..precisamos implementar esse método também!
        }
    }
    
 Bom sabemos que um Passarinho não é um avião, então não podemos HERDAR de AVIÃO o metodo VOA, pois ele viria com ligaMortor, e um Passarinho não liga motor.
 
 A melhor maneira de fazermos isso é com COMPOSIÇÃO, ela funciona da seguinte forma:
 
         class Aviao {

            constructor(nome) {
                this._nome = nome;
            }

            voa() {
                alert(`${this._nome} está voando`);
            }

            //mais codigo
         }

        class Passarinho {

            constructor(nome) {
                this._nome = nome;
                // guarda uma instância de avião
                this._aviao = new Aviao(nome);
            }

            voa() {
                // usa o método voa de Aviao
                this._aviao.voa();
            }
        }
        
    Ela guarda uma instância de avião, e a utiliza no metodo desejado.
    
    Um metodo menos verboso de fazer a Composição
    
    --- Menos VERBOSO ---
    
    class Passarinho {

        constructor(nome) {
            this._nome = nome;
        }

        voa() {
            // executa o método `voa` de `Avião` usando como contexto a instância de `Passarinho`
            Reflect.apply(Aviao.prototype.voa, this, []);
        }
    } 

---------------- Maneiras de resolver o problema do this dependendo do caso. ----------------


class Relogio {

    constructor() {
        this._segundos = 0;

        setInterval(function () {
            console.log(++this._segundos);
          }, 1000);
    }
}

var relogio = new Relogio();

O principal erro deste código está na função passada para setInterval, aonde fazemos o ++this._segundos. Como setInterval é global e acessível em qualquer canto do nosso código, ele pertence ao objeto global window, logo seu this aponta para window e não para nossa classe Relogio. Como window não possui a propriedade _segundos, o incremento resultará em NaN, pois não podemos incrementar uma variável que é undefined.

class Relogio {

    constructor() {

        let self = this; // guardando o this que é a instância da classe `Relogio`
        this._segundos = 0;

        setInterval(function () {
            console.log(++self._segundos); // acessando a variável self, que é a instância de `Relogio` 
          }, 1000);

    }
}

var relogio = new Relogio();

---- Utilizando arrow function ----

class Relogio {

    constructor() {
        this._segundos = 0;
        setInterval(() => console.log(++this._segundos), 1000); // usando arrow function. O this é o this de `Relogio`, e não `window`. 
    }
}

var relogio = new Relogio();



----------------  Como definir um parâmetro DEFAULT? ----------------

-- CASO NÃO OUVER PARÂMETRO O VALOR PADRÃO SERÁ TEXTO EM BRANCO ( '' ) --

constructor(texto=''){ 
        this._texto = texto;
    }

-- CASO NÃO OUVER PARÂMETRO O VALOR PADRÃO DE X E Y SERÁ 0 --
function calculo(x=0,y=0){ return x+y; } // caso não ouver parâM

----------------------  Como era antes do ES6? ----------------------

//Criando a classe
function Pessoa(nome, sobrenome) {
    this.nome = nome;
    this.sobrenome = sobrenome;
}

// método de instância
Pessoa.prototype.obterNomeCompleto = function() {
    return this.nome + ' ' + this.sobrenome;
};

// declarando equivalente a método estático

Pessoa.metodoStaticoQualquer = function() {

    console.log('Método estático chamado');

};

-------------------------  Convenções JS -------------------------


this._inputData = data; -> propriedades com (_)underline no começo, indica ao programador, que aquela 
    propriedade não deve ser alterada.
    
_metodoX() -> metodos com underline no começo, indica que aquele metodo não deve ser chamado por fora, APENAS A PROPRIA CLASSE DEVE USÁ-LO.


-------------------------  Excessão EXCEPTION JS -------------------------

throw -> lança uma exceção.
    Exemplo:
        throw "Erro2"; // gera uma exceção com um valor string
        throw 42;      // gera uma exceção com o valor 42
        throw true;    // gera uma exceção com o valor true
        throw new Error("Esta classe não pode ser instanciada.");
-------------------------  Curiosidades -------------------------

Em Javascript 0 é considerado FALSE.
 Exemplo:
 if(0)
    Oi
 else
    ola
    
    o resultado será ola, pois 0 é false.
    

-------------------------  Operador Ternário -------------------------

 Operador Ternário
    operador ternário, a expressão (expr1) ? (expr2) : (expr3) é avaliada para expr2 se expr1 é avaliada como TRUE, ou expr3 se expr1 é avaliada como FALSE.
    
  SINTAX: condicao ? resultado1 : Senaoresultado2
  
  Exemplo:
  
  let numeros = [3,2,11,20,8,7];
  let novosNumeros = numeros.map(item =>  item % 2 ? item * 2 : item);
  console.log(novosNumeros);

-------------------------  Arrow function -------------------------

IMPORTANTE -> Arrow function tem o seu escopo LÉXICO, o que eu quero dizer com isso? que o this de arrow function não é dinâmico.



Minimizando código com arrow function.

  Exemplo SEM Arrow function:
  
    metodo(function(item1){
        //codigo aqui.
    });
  Exemplo COM Arrow function:
  
    metodo((item1) => {
        //código aqui.
    });
    
  Quando se tem apenas UMA instrução no BLOCO DA AERO FUNCTION, eu posso OMITIR OS {} o RETURN e o PONTO E VIRGULA(;).
  Ficando assim o código, bem mais limpo.
    
    .map((item, indice) => item - (indice % 2))

-------------------------  Spread Operator -------------------------


Ele sempre pega o primeiro item do vetor e coloca dentro da função.

Exemplo:
    array = [3,5];

    minhaFuncao(x,y){return x+ y;}
    
    minhaFuncao(...array); // minhaFuncao(3,5) seria esse o resultado.
    
    SE FIZESSEMOS SEM SPREAD OPERATOR ficaria assim:
    
    minhaFuncao(array[0], array[1]); // minhaFuncao(3,5) seria esse o resultado.
    

O famoso tres pontinhos

... -> O  Spread Operator permite uma expressão ser expandida em locais onde múltiplos argumentos (por chamadas de função) ou múltiplos elementos (por array literais) são esperados.

    Exemplos:
    
    Para chamadas de função:
      minhaFuncao(...objIteravel);
        function minhaFuncao(x, y, z) { }
            var args = [0, 1, 2];
            minhaFuncao(...args);
            
    Para array literais:
      [...objIteravel, 4, 5, 6];
      
      var partes = ['ombros', 'joelhos'];
      var letra = ['cabeca', ...partes, 'e', 'dedos']; // ["cabeca", "ombros", "joelhos", "e", "dedos"]
      
    Desestruturação:
      [a, b, ...objIteravel] = [1, 2, 3, 4, 5];
      
      var objIteravel = [3,4,5];
      
      var array = [0,1,2];

      array = [...objIteravel]; // array = [3,4,5];
      
      

    
    

----- Transformando um input data, em um Objeto Date() ------

No input de data, recebemos o valor como string.

Para poder manipular a data, teremos que transformar essa STRING de DATA, em um Objeto Date(), para isso devemos fazer o seguinte.

  let data = new Date(this._inputData.value.split("-"));
  
  OU
  
  let data = new Date(this._inputData.value.replace(/-/g, ","));
  
  
  no primeiro método acontece o seguinte.
  
  o split transforma minha string em vetor separando por "-", o resultado ficará assim ["2018","03","14"], e o proprio metodo interno do objeto Date, tem um metodo que pega esse array junto ele como string, e separa por virgula ele, ele utiliza esse método, ["2018","03","14].join(","); esse metodo vai pegar o array, transformar em string, e separar por virgula.
  
  o segundo método economiza processo(eu acho), pois utilizamos regex para resolve-lo, ele simplesmente pega a data do tipo string e substitui o - por virgula, ficando assim a string: antes: 2018-03-14 depois com regex 2018,03,14 e é só o que o objeto Date  precisa, uma string de data, separada por virgula.
  
   


------------------- Melhoria de Performance -------------------------

Fazer um Cache ou caching de coisas que são muito chamadas é uma boa prática, e reduz o tempo de processamento da função ou método.

  Exemplo de caching:
  
    constructor(){
        let $ = document.querySelector.bind(document);
        
        this.inputData = $("#data");
        this.inputQuantidade = $("#quantidade");
        this.inputValor = $("#valor");
    }
    
    console.log(this.inputData.value);
    
    Nesse caso, quando eu criar meu objeto Negociacao, ele já irá percorrer a arvore DOM uma única vez, 
    e quando eu precisar desses elementos, eu apenas referêncio eles com this, e não faço uma NOVA busca por eles, evitando assim uma má performance.

------------------- Template string (ESTUDAR SOBRE ! ! ! ) -------------------------

  ---- Como funciona? ----
  
  Antigamente no ES5 Usavamos a seguinte sintax para concatenar strings:
  
    Exemplo utilizando ES5:
    
      var nome = "Nicolas";
      var idade = "23";
      
      var msg = "O " + nome + " tem " + idade + " anos."; // exibirá O Nicolas tem 23 anos.
      
      
    Exemplo utilizando ES6:
    
      let nome = "Nicolas";
      let idade = "23";
      
      let msg = `O ${nome} tem ${idade} anos.`;
      
      IMPORTANTE: Sempre utilize o crase(``) no início e no final, para que o JS possa identificar que é um Template String;
      
      
Uso de template com innerHTML:
  Exemplo:
    
        _template(){
        return `
            <table class="table table-hover table-bordered">
                <thead>
                    <tr>
                        <th>DATA</th>
                        <th>QUANTIDADE</th>
                        <th>VALOR</th>
                        <th>VOLUME</th>
                    </tr>
                </thead>

                <tbody>
                </tbody>

                <tfoot>
                </tfoot>
            </table>    
            `;
    }
    
    update(){
        this._element.innerHTML = this._template();
    }
    
    Eu seleciono um elemento, e coloco dentro dele o template, porque isso funciona, se o retorno é uma string?
     porque o innerHTML converte sua estrutura html string para DOM.
      
      
    --- Avançando no template String ---
    
    <table class="table table-hover table-bordered">
        <thead>
            <tr>
                <th>DATA</th>
                <th>QUANTIDADE</th>
                <th>VALOR</th>
                <th>VOLUME</th>
            </tr>
        </thead>

        <tbody>
            ${
                model.map(n => `

                    <tr>
                        <td>${DateHelper.dataParaTexto(n.data)}</td>
                        <td>${n.quantidade}</td>
                        <td>${n.valor}</td>
                        <td>${n.volume}</td>
                    </tr>

                `).join('')
            }
        </tbody>
        
${} -> aceita o retoRno de apenas uma instrução como é o caso, porem, nada
    me impede de fazer uma função IMEDIATA OU (Immediately-invoked function expression (IIFE)).
    
    Exemplo: 
        <tfoot>
            <tr>
            <td colspan="3"></td>
            <td>${
                (function(){
                    let total = 0;
                    model.forEach(m => total += m.volume)
                    return total;
                })()
            }</td>
            </tr>
        </tfoot>
        
    Com isso eu posso colocar mais de uma instrução dentro de ${}
    
    --- ENXUGANDO NOSSA LÓGICA ---
    
        <tfoot>
            <tr>
            <td colspan="3"></td>
            <td>${
                model.reduce((total,n) => total + n.volume, 0,0)
            }</td>
            </tr>
        </tfoot>
        
    Utilizando o metodo reduce + arrow function, nossa lógica ficou bem mais simples.
------------------- SHALLOW(RASO) -------------------------

O metodo Object.freeze(nomeObjeto), é um método de segurança SHALLOW(raso), o que eu quero dizer com isso.

Exemplo:
  constructor(data, quantidade, valor){
        
        this._data = new Date(data.getTime()); // não é shallow, pois está recebendo um objeto, e um objeto é mais profundo pois todo objeto tem seus metodos.
        this._quantidade = quantidade; // shallow
        this._valor = valor; // shallow
        
        Object.freeze(this);
    }
    
    Eu quero dizer que ele só congela o que é da "superfície/ shallow / raso", caso a propriedade seja um objeto, já não é mais (raso, "superfície"), pois todo objeto é mais profundo pois todo objeto tem seus metodos.

------------------- Declaração de Variáveis -------------------------

var -> uso comum no javascript, porem não recomendado, pois ela funciona fora de escopo do bloco também.
    Utilizando VAR, ele funciona apenas como escopo de função, e NÃO de bloco.
    
let -> uso recomendado, pois ela faz juz ao escopo de bloco.

  Exemplo de uso com VAR:
  
   // exibira o numero de 0 até 100
    for(var i = 0; i <= 100; i++){  
        console.log(i); 
    } 
   console.log(i) // exibirá 101, porque? porque variáveis declaradas com var, não possuem escopo de bloco, apenas escopo de função.
   
   
   Exemplo de uso com LET:
   
   // exibira o numero de 0 até 100
    for(let i = 0; i <= 100; i++){  
        console.log(i); 
    } 
   console.log(i) // exibirá " i is not defined ", porque ele não está definido?, pq como let faz juz ao escopo de bloco, a variável i só será enchergada no bloco 
        declarado.
   
------------------- Programação defensiva -------------------------

  Todo objeto pode ser alterado, caso ele tenha o método para ser modificado.
    Exemplo:
      constructor(data, quantidade, valor){
        
        this._data = data;
        this._quantidade = quantidade;
        this._valor = valor;
        
        Object.freeze(this); // congelo o objeto, assim ele não pode ser mais modificado.
    }
    
    get data(){
        return new Date(this._data.getTime());
    }
    
    Nesse exemplo, eu utilizo o metodo freeze, que não deixa a propriedade ser modificada, porem, a nossa propriedade ._data RECEBE UM OBJETO como valor, e todo objeto pode ser alterado, caso ele tenha o método para ser modificado.
    
    Logo... 
    
    --- ARRAY ---
    
    Como impedir que consigam modificar um array?
      usamos um array vazio [] e concatenamos ele com o metodo .concat(array) e depois colocamos nosso array como parâmetro.
    get negociacoes(){
        return [].concat(this._negociacoes);
    }
    
    

------------------- Getters e Setters Javascript -------------------------

  ---- Criando um getter ----
    get volume(){
        return this._volume;
    }
      var n1 = new Negociacao(new Date(), 2, 500); // Essa linha eu crio um novo objeto0 Negociacao.
        n1.volume; // essa linha exibe o volume.


------------------- Construtor e a Classe -------------------------

  Criamos classes em javascript dessa maneira:

  class NomeClasse {

  }

  Caso tenha construtor ficaria assim,

  class Negociacao {

      constructor(){
      
        this.data = new Date();
        this.quantidade = 1;
        this.valor = 0.0;
      }

  }
--------------------- Trabalhando com objetos ---------------------

  ------ Instanciando o objeto ------

    Ao instanciar o objeto automaticamente o THIS do construtor, passa a ser referenciado pela variável que recebeu o objeto.
    EXEMPLO:
      var n1 =  new Negociacao(); -> n1 passa a ser o this do construtor, logo ele tem acesso a todos as suas propriedades.
      console.log(n1.data);
      console.log(n1.quantidade);


  ------ Métodos de um objeto instanciado --------

      class Negociacao{

          constructor(data, quantidade, valor){

              this.data = data;
              this.quantidade = quantidade;
              this.valor = valor;
          }

          //Esse é o METODO
          obtemVolume(){
              return this.quantidade * this.valor;
          }


      }

  ------ Como acessar os metodos de objetos? --------

      após instânciar o seu objeto acesse seus métodos atravez do ponto(.)
      EXEMPLO:
          // INSTANCIANDO OBJETO
          var n1 =  new Negociacao(new Date(), 2, 100);

          // ACESSANDO SEU MÉTODO
          var volume = n1.obtemVolume();


------------------- MVC -------------------------

  MVC:

    Model -> recebe a REGRA DE NEGÓCIO, o banco de dados.
    View -> Só exibe para o usuário.
    Controller -> SEMPRE recebe as requisições do usuário.


    ---- Ciclo de um MVC ----
      -- Sem Banco de Dados --
          Controller -> View
      -- Com Banco de Dados --
          Controller -> Model -> Controller > View

---------------------- Programação Orientada a Objetos ---------------------------

  --- CLASSE COM CONSTRUTOR ---
  
    Toda classe que contem um construtor, só poderá ser chamada com o new, 
    caso ela NÃO seja chamada com o new, dara um erro.
    
    E toda classe que tenha o construtor inicializado com alguma propriedade, ela pode ser acessada pelo objeto da classe, que foi criado, exemplo:
    
    let n1(objeto) = new Negociacao(); (NOVA instancia de negociacao)
    
    EXEMPLO DE CLASSE: 
    
        class Negociacao{

            constructor(){

                this.data = new Date();
                this.quantidade = 1;
                this.valor = 100;
            }
        }
    O this do javascript é dinâmico, ou seja quando eu crio um obj n1, e acesso as propriedades desse objeto, por exemplo:
        let n1 = new Negociacao();
        n1.quantidade;
        n1.quantidade = 10;
        let n2 = new Negociacao();
        n2.quantidade;
        n2.quantidade = 10;

    Eu consigo alterar ambos sem afetar o outro, pois o this sempre aponta para a instancia que está executando naquele momento.
    
PRIVATE - APENAS A Própia classe pode ter acesso.

  ---- ABSTRAÇÃO ----

      Exemplo:

        Cachorro -> Objeto
          cor -> propriedade
            latir(); -> metodo do objeto.

      ISSO FOI UMA ABSTRAÇÃO DO MUNDO REAL PARA O MUNDO DA PROGRAMAÇÃO.
      
  ---- ENCAPSULAMENTO ----
  
    É proteger o seu código, para que ele não seja alterado, é adicionar camadas de segurança a ele.
      Exemplo em JAVA:
        private cor = azul; -> encapsulei minha propriedade cor, e ela só poderá ser modificada, caso eu de acesso a ela através de metodos(setters e getters).
      Exemplo em JavaScript:
        Adicione _(underline) a frente da propriedade que você deseja que não seja modificada, para que você e também o futuro programador entenda que
        aquela variável em questão não pode ser modificada.
          EXEMPLO:
            this._data = data;
            this._quantidade = quantidade;
            this._valor = valor;
            
        e sempre faça metodos de acesso as propriedades,
          Exemplo:
                getData(){
                    return this._data;
                }
                getQuantidade(){
                    return this._quantidade;
                }
                getValor(){
                    return this._valor;
                }
    ----- Metodos para encapsular(Deixar mais seguro os dados do seu objeto) ----
    
      Utilizar get para chamar os valores das propriedades.
        get.valor;
        
      Utilizar o metodo Object.freeze(nomeObjeto), para congelar o objeto.
       Exemplo:
            constructor(data, quantidade, valor){

                this._data = data;
                this._quantidade = quantidade;
                this._valor = valor;

                Object.freeze(this);
            }
      
      No exemplo acima, o meu construtor recebe os dados, e assim que eu recebo os dados eu congelo eles, isso é, quando eu instancio um novo objeto, os valores desse objeto não poderá ser alterado.
      
      
    ---- HERANÇA ----
    
    Exemplo de herança:
    
    class MensagemView extends View{
        constructor(elemento){
            super(elemento);
        }
    }
    
    quando só temos parâmetros da classe PAI na classe filha, não precisamos do construtor, ficaria assim:
    
    class MensagemView extends View{

    }
    
    quando temos parâmetros também na classe filha, nosso constructor fica assim:
    
    class MensagemView extends View{
        constructor(elemento, outroParametro){
            super(elemento);
            this._outroParametro = outroParametro;
        }
    }
    
    no código acima, estamos indicando que o parâmetro ELEMENTO faz parte do construtor da SUPER, e que o outroParametro faz parte da própria classe.
    
    
    
    Uma subclasse herda métodos e atributos de sua superclasse
      
      
------ METODO ESTÁTICO / STATIC METHOD ------
      
    Metodos estáticos não podem ser instanciados.
    Metodos estáticos são acessados diretamente pela classe.
      Exemplo:
      METODO ESTÁTICO. nome da classe desse método é DataHelper
        static dataParaTexto(data){
          return `${data.getDate()}/${(data.getMonth()+1)}/${data.getFullYear()}`;
        }
        
        ERRADO:
        let helper = new DataHelper(); //  helper.dataParaTexto(data); -> não é possivel chamar metodos estaticos através de uma instancia da classe.
        
        CORRETO:
        DataHelper.dataParaTexto(data); // metodos estáticos são chamados diretamente da classe.
        
    ------ METODO PRIVATE / PRIVATE METHOD ------
    
    _metodo(texto){
        // codigo
    }
    
    O método privado só pode ser acessado somente pela própria classe.
    
    ------ METODO ABSTRATO / ABSTRACT METHOD ------
    
    Em JAVA fazemos assim:
    
        // métodos abstratos //
    não possuem corpo, da mesma forma que
    as assinaturas de método de uma interface

    public abstract void ligar();
    public abstract void desligar();
    
    EM JAVASCRIPT Não temos metodos abstratos, porem para simular, fazemos assim:
    
    Em sua classe PAI, definimos o MESMO metodo da classe filha, e colocamos um erro para que o programador, entenda que DEVE ter aquele metodo na sua classe filha.
    
    EXEMPLO:
    
    -- CLASSE PAI: --
    
    class View{
    
        template(){

            throw new Error("O método template deve ser implementado.");
        }
    }
    
    -- CLASSE FILHA --
    
    class MensagemView extends View{
    
        template(model){
            return model.texto ? `<p class="alert alert-info">${model.texto}</p>` : `<p></p>`;
        }
    }
    
    CASO A CLASSE FILHA NÃO TENHA O METODO TEMPLATE, DISPARARA UM ERRO, CASO ELA TENHA O METODO IMPLEMENTADO, A CLASSE FILHA IRÁ SOBRESCREVER O METODO DA CLASSE PAI.

---------------------- Metodos Javascript ---------------------------

Object.freeze(nomeObjeto); -> congela um objeto: isto é, impede que novas propriedades sejam adicionadas a ele; impede que as propriedades existentes sejam
    removidas; e impede que propriedades existentes, ou sua inumerabilidade, configurabilidade, ou capacidade de escrita sejam alteradas.

Object.isFrozen(nomeObjeto); -> Verifica se um objeto está congelado, se estiver retorna true, se não estiver retorna false.

bind(this); -> EXEMPLO:

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector; // SEM BIND
        
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}

Desta forma, ficou menos trabalhoso escrever o código. Mas se o executarmos como está, veremos uma mensagem de erro no navegador.

Não funcionou colocarmos o querySelector na variável $ para criarmos um alias. Por que não funcionou? O querySelector é uma função que pertence ao objeto document - chamaremos tal função de método. Internamente, o querySelector tem uma chamada para o this, que é o contexto pelo qual o método é chamado. Logo, o this é o document. No entanto, quando colocamos o querySelector dentro do $, ele passa a ser executado fora do contexto de document e isto não funciona. O que devemos fazer, então? Queremos tratar o querySelector como uma função separada. Nós queremos que ao colocarmos o querySelector para o $, ele mantenha a associação com o document. Para isto, usaremos o bind() :

class NegociacaoController {

  adiciona(event) {
        event.preventDefault();

        let $ = document.querySelector.bind(document);
        let inputData = $('#data');
        let inputQuantidade =  $('#quantidade');
        let inputValor = $('#valor');

        console.log(inputData.value);
        console.log(inputQuantidade.value);
        console.log(inputValor.value);

  }
}

array.concat(array, "nicolas"); -> o Array concat, ele concatena tudo 
    que você passar como parâmetro, e transforma em um array.
    Exemplo.
        let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
        let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
        let lista = listaDeNomes1.concat(listaDeNomes2);

        exibeNoConsole(lista);
    Exemplo MELHORADO.
        let listaDeNomes1 = ['Flávio', 'Rogers', 'Júlia'];
        let listaDeNomes2 = ['Vieira', 'Fernanda', 'Gerson'];
        exibeNoConsole([].concat(listaDeNomes1, listaDeNomes2, 'Rômulo'));

array.join(separator) -> Junta todos os elementos de uma array (ou um array-like object) em uma string e retorna esta string.
    Os elementos serão separados por um separador especificado. O separador padrão é vírgula (,),
    Exemplos:
        var elements = ['Fire', 'Wind', 'Rain'];

        console.log(elements.join());
        // expected output: Fire,Wind,Rain

        console.log(elements.join(''));
        // expected output: FireWindRain

        console.log(elements.join('-'));
        // expected output: Fire-Wind-Rain
        
    
array.reverse() -> Basicamente ele inverte os valores do vetor.
    Exemplo:
      let vet = [0,1,2,3];
      LET vetorReverso = vet.reverse(); // vetorReverso = [3,2,1,0]
      
array.filter(callback) -> filter() chama a função callback fornecida, uma vez para cada elemento do array, e constrói um novo array com todos os valores para os quais o callback retornou o valor true ou  um valor que seja convertido para true.
  Exemplo:
    function isBigEnough(value) {
      return value >= 10;
    }

    var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
    // filtrado é [12, 130, 44]
    
arr.map(callback[, thisArg] -> O método map() invoca a função callback passada por argumento para cada elemento do Array e devolve um novo Array como resultado.

    Parâmetros
    
    callback
        Função cujo retorno produz o elemento do novo Array. Recebe três argumentos:
        
    valorAtual
        O valor do elemento original do Array de origem. 
        
    indice
        O índice do elemento atual que está sendo processado no array.
        
    array
        O Array de origem.
        
    thisArg
        Opcional. Valor a ser utilizado como o this no momento da execução da função callback.
        
    Exemplo:
             let data  = new Date(
            ...
            this.inputDataValue
            .split("-")
            .map(function(item, indice){
               return item - (indice % 2); 
            })
        );
    Nesse exemplo estou pegando o vetor de uma data["1995","01","24"], uso a função map para percorrer o vetor, e caso o vetor esteja na posição [1] ele decrementa 1 do valor atual do vetor da posição 1.
    
    Em resumo, estou fazendo isso.
    [0] // 1995
    [1] // 01
    [2] // 24
    
    SINTAX: 
      return item - (indice % 2);
    
    1° loop
      return 1995 - (0 % 2) // resultado 0, e 1995 - 0 é 1995
    2° loop
      return 01 - (1 % 2) // resultado 1, e 01 - 1 é 0
    3° loop
      return 24 - (2 % 2) // resultado 0, e 24 - 0 é 24
      
    Porque estou reduzindo o mes de uma data? porque o javascript em formato de numero, entende o mes de 0 a 11, 0 seria janeiro e 11 dezembro, caso passe multiplas strings deste modo new Date("1995","01","24"), ele terá o mesmo entendimento de numero, e contará o mês de 0 a 11.
    
array.reduce(callback[, valorInicial]) -> acumula um valor e retorna ele.
    Exemplo:
        model.reduce((total,n) => total + n.volume, 0,0)
    Exemplo:
        [0, 1, 2, 3, 4].reduce(function(valorAnterior, valorAtual, indice, array) {
          return valorAnterior + valorAtual;
        },valorInicialDoValorAnterior);
        // 10
        
Reflect.apply(target, thisArgument, argumentsList) - >
    target -> função a ser chamada
    thisArgument -> contexto da função
    argumentsList -> array com parâmetros da função.
    
    Exemplo:
        this._listaNegociacoes = new ListaNegociacoes(this, function(model){
            this._negociacaoView.update(model); 
        });
        
        constructor(contexto, armadilha){
        
            this._contexto = contexto; // this da controller
            this._armadilha = armadilha; // função "injetora"
        }
        
        Reflect.apply(this._armadilha, this._contexto, [this.negociacoes]);
        
array.includes(valor) -> procura um "valor" dentro do array, e retorna true se encontrar e false caso não encontre.
    Exemplo: ['adiciona','esvazia'].includes('esvazia');

arguments -> retorna um vetor com os parâmetros que foram passados em uma função.

---------------------- ECS5 ---------------------------

----- Immediately-invoked function expression (IIFE) -----

(function(){})();

O IIFE significa “Immediately-invoked function expression”, mas podemos chamá-lo de função imediata. Como o próprio nome diz, ela executa a função imediatamente depois de criada. Mas por que usar? Encapsulamento! 
