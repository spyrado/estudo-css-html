**************************** Angular ****************************

Angular foca em ever green browsers, isto é, suportará sempre as duas últimas versões vigentes dos navegadores
do mercado.  Por exemplo, se a última versão do Chrome é 65, ele suportará esta versão e a anterior, apenas.

------------------- MEU PADRAO DE SINTAX -------------------

<img 
    (click)="fazAlgo()" 
    [binding]="algo" 
    id="algo" 
    class="algo"
    src="caminho"
    alt="algo">

------------------- ANGULAR ATALHOS TERMINAL -------------------

ng generate service pasta/arquivo -> cria um servico
    ng g s pasta/arquivo <- atalho

ng generate component pasta/arquivo -> cria um componente
    ng g c pasta/arquivo <- atalho

ng generate module pasta/arquivo -> cria um modulo
    ng g m pasta/arquivo <- atalho

------------------- ANGULAR DUVIDAS BASICAS -------------------

---- declaration MODULO ----
    Um Modulo, ao colocar seus components em declarations, TODOS OS OUTROS COMPONENTS ficam visivel entre eles, isso é,
    eles fazem parte do modulo, e se conversam entre eles.
        @NgModule({
            declarations: [ 
                PhotoComponent
            ]
        })

---- exports MODULO ----

    Um  moduloX só conseguira enxergar os components do moduloY, caso o moduloY tenha exportado esses components.
        photos.module.ts: (moduloY)
            @NgModule({
                declarations: [ 
                    PhotoComponent
                ],
                exports: [
                    PhotoComponent
                ]
            })
        app.module.ts: (moduloX)
            @NgModule({
                imports: [
                    PhotosModule
                ]
            })

------------------- ANGULAR CLI -------------------

    Ele é uma interface de linha de comando para o angular, por ele conseguimos através de alguns comandos
    simples, criar toda a infraestrutura do projeto, sem muito esforço.

    Baixamos ele na url: https://cli.angular.io/
        IMPORTANTE PRECISAMOS DE PERMISSAO DE ADMINISTRADOR PARA FAZER O DOWNLOAD, Se n gerara um erro:
        OU digitando:
    sudo npm install -g @angular/cli@6.0.7
    
    Precisaremos de um node.js na versão 8.9 ou superior para executar o angular-cli na versao 6.0.7
        https://nodejs.org/en/blog/release/v8.9.0/

    Após isso, vamos até uma pasta de Projetos (por exemplo)

    E damos o primeiro comando para criar o projeto em angular:
        ng new my-dream-app
    Ele ira criar TODAS as pastas/dependencias do projeto.
        para acessa-lo digite:
            cd my-dream-app
    Para iniciar a aplicação, digitamos:
        ng serve --open 
    O --open abre o navegador após o servidor iniciar

    DICAS: SEMPRE ABRA A PASTA RAIZ DO SEU PROJETO PELO VS CODE, POIS O VS CODE TEM QUE ENCONTRAR ALGUNS ARQUIVOS DE
        CONFIGURAÇÃO QUE ESTAO NELA.

------------------- ANGULAR Components -------------------

    Em angular, tudo é um componente.

    ---- O que é um componente? ----

    O componente guarda um artefato/objeto que guarda um comportamento(o que fazer), a apresentação(o css) e a marcação
    html(a estrutura).

    ---- Como criar um componente? ----

    primeiro criamos a classe e exportamos ela, e a classe só vira um componente, quando utilizamos o decoratos
        @Component.

    import { Component } from '@angular/core';

    @Component({
        selector: 'app-root',
        templateUrl: './app.component.html',
        styleUrls: ['./app.component.css']
    })
    export class AppComponent {
        title = 'app';
    }

    ---- Como configuramos e chamamos um componente? ----

        Em:
            @Component({
                selector: 'app-root',
                templateUrl: './app.component.html',
                styleUrls: ['./app.component.css']
            })
        Definições do componente:
            selector -> definimos o nome do componente.
            templateUrl -> definimos o html
            styleUrls -> definimos os css

------------------- ANGULAR SINTAX -------------------

O BrowserModule só deve ser importado no modulo principal da aplicação.

-> Componentes declarados no array declarations de um módulo são visíveis para os componentes também
declarados no array.

-> Um componente obrigatoriamente precisa pertencer a um módulo.


--- Diretivas ---

app.component.ts:

Temos uma classe, q tem como valor array de objetos photos.
    export class AppComponent {

        photos = [
            {
            url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Sultan_the_Barbary_Lion.jpg/440px-Sultan_the_Barbary_Lion.jpg',
            description: 'Leão'
            },
            {
            url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Lioness_Etosha_NP.jpg/500px-Lioness_Etosha_NP.jpg',
            description: 'Leoa'
            },
            {
            url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Sultan_the_Barbary_Lion.jpg/440px-Sultan_the_Barbary_Lion.jpg',
            description: 'Leão'
            },
            {
            url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/Lioness_Etosha_NP.jpg/500px-Lioness_Etosha_NP.jpg',
            description: 'Leoa'
            }
        ];
    }

app.component.html:

    Estou fazendo um for, para exibir a lista de fotos q a classe AppComponent contem.

    <ap-photo 
        *ngFor="let photo of photos" // estou falando q a variavel photo recebe photos ( de AppComponent)
        [url]='photo.url' // cada iteracao no for eu tenho um objeto e passo ele pra url, indico q essa propriedade vem
                             da classe AppComponent com [] na url [url], isso vai indicar q está vindo da classe
        [description]='photo.description'> // mesma coisa aqui.
    </ap-photo>

    e assim eu tenho varias imagens ;)

--- Criando Features / modulos / e exportando elas ---

Primeiro é uma boa pratica criar um modulo para features, exemplo:
    tenho o component thead, um component tbody e um outro tfoot,
    crio uma feature chamada table, dentro dessa feature vai ter um modulo,
    e vamos importar E exportar as dependencias dessa tabela, de acordo com a necessidade.

--- Como fazer isso? ---

photos
    photo
        //componentes de photo
photos.module.ts // aqui eu pego todas as dependencias de photo

photos.module.ts:

    import { NgModule } from "@angular/core";
    import { PhotoComponent } from "./photo/photo.component";

    @NgModule({
        declarations: [ PhotoComponent ], // importo o component
        exports: [ PhotoComponent ] // exporto esse componente, quando faco isso, ele fica visivel para outros modulos, 
                                        conseguirem enchergar ele
    })
    export class PhotosModule{

    }
app.module.ts:

    Aqui eu importo o modulo de photos:

    import { BrowserModule } from '@angular/platform-browser';
    import { NgModule } from '@angular/core';
    import { AppComponent } from './app.component';
    import { PhotosModule } from './photos/photos.module';


    @NgModule({
    declarations: [
        AppComponent
    ],
    imports: [
        BrowserModule,
        PhotosModule // aqui eu importo ele, se no Photos Module eu n tivesse exportado nada, 
                        nenhum componente ficaria visivel, para esse modulo, iria gerar um erro.
    ],
    providers: [],
    bootstrap: [AppComponent]
    })
    export class AppModule { }


--- Inbound properties ---

    IMPORTANTE!! O Angular só DETECTA numa inbound propertie uma alteracao quando essa variavel,
    recebe uma nova ATRIBUICAO nela.
    Exemplo:
        Se vc fizer this.photos.push(photos); // ele n detecta q foi alterado, e n vai atualizar a lista de photos.
        Para a listagem funcionar deve ser feito uma nova ATRIBUICAO this.photos = this.photos.concat(photos);

    Permite que o componente receba valores externos quando usado na forma declarativa no template de outros componentes.

    Quando passo atributos para um component, estou falando que esses atributos podem receber por meio dessa forma declarativa, valores variados.

    <ap-photo url='.img/outra-img.png' description='imagem 2' ></ap-photo>

    E para isso funcionar, devemos declarar na classe criadora, em suas respectivas propriedades os decorators, para fazer esse link, com @Input

    export class PhotoComponent {
    
        @Input() description = '';
        @Input() url = '';
    }

--- PADRAO DE CHAMADA DE ARQUIVOS ---

    Uma convensao adotada no site do angular, o correto é separar os imports do angular dos seus, exemplo:
        // Angular imports
        import { BrowserModule } from '@angular/platform-browser';
        import { NgModule } from '@angular/core';
        import { AppComponent } from './app.component';

        //Seus imports
        import { PhotoComponent } from './photo/photo.component';

--- Nomenclatura de arquivos/classes ---

Exemplo:
    MenubarComponent {} // Classe
    menubar.component.ts // arquivo
    menubar.component.html // arquivo
    menubar.component.css // arquivo

    CalopsitaComponent {} // Classe
    calopsita.component.ts // arquivo
    calopsita.component.html // arquivo
    calopsita.component.css // arquivo


Classe de exemplo:

    export class AppComponent {
        title = 'alurapic';
        description = 'Leão';
        url = 'https://img.elo7.com.br/product/zoom/1C33C7D/quadro-tela-animais-leao-decoracao-telas-animal-0005-quadro-de-leao.jpg';
    }

{{}} -> Angular Expression, Utilizamos para dar valores ao conteudo das tags, exemplo:
    <h1> {{ title }} </h1>
[] -> One way data binding ("data binding unidirecional"), utilizamos apenas em atributos, exemplo:
    IMPORTANTE: Ele é unidirecional, então ele faz o caminho do seu componente até o seu template, e NUNCA o contrário.
    <img [src]="url" [alt]="description">

RESUMO: Utilizamos {{ }} dentro de tags e [ ] para atributos

----- Component -----

É uma boa prática em Angular, usar um prefixo antes do nome do seletor, o prefixo pode ser o nome da empresa, 
    oq vc quiser, no caso do exemplo abaixo o prefixo ap, significa alurapic.

    import { Component } from "@angular/core";

    @Component({
        selector: 'ap-photo'
    })
    export class PhotoComponent {

    }

------------------- ANGULAR CARREGANDO ARQUIVOS GLOBAIS CSS/JS -------------------

    Utilizamos a tag link no html para um CSS Global?
    Não! No Angular, quando precisamos importar um CSS global como o Bootstrap, Normalize, CSS Reset ou outro similar, isso não funciona desta forma. 
    Isto porque esses arquivos CSS precisam estar no processo de build, de construção da nossa aplicação, tanto no ambiente de desenvolvimento 
    quanto no ambiente de produção.

---- Como fazemos isso no Angular? ----
    Em angular.json:
        temos a parte de build, lá dentro temos as chaves:
            "styles": [
                "src/styles.css"
            ],
                "scripts": []
            },
        é aqui que colocamos nossos CSS / JS GLOBAIS, APENAS OS ARQUIVOS GLOBAIS.

    Exemplo:
        Baixamos bootstrap via npm,
        e chamamos ele na chave style, ficando assim:
        "styles": [
            "src/styles.css",
            "./node_modules/bootstrap/dist/css/bootstrap.min.css"
        ],

------------------- WEB API -------------------

    É o servidor que tem a responsabilidade de fornecer os dados para a aplicação Angular em uma Single Page Application.

------------------- HttpClient / HttpParams -------------------

http.get() -> solicita a url porem n faz nada com ela, para fazer algo temos que dar um subscribe

http.get(url).subscribe(); -> o subscribe retorna a resposta que veio do servidor, ele contem 2 callbacks, exemplo:
    http
        .get(url)
        .subscribe(callbackRespostaDoServidor,callbackError);

const params = new HttpParams()
            .append('page', page.toString());
Estou adicionando o parametro page com seu respectivo valor em uma api chamada flavio/photos  ?page=2
    vou passar minha const params, para o meu HttpClient no get
        this.http
            .get<Photo[]>(API + '/'+userName+'/photos',{params}); // o segundo parametro passamos os parametros da url,
                no caso eu so chamo de params pq o nome da propriedade é params e o nome da minha variavel
                tambem é params, sendo assim em vez de colocar params: params, eu reduzo para params.



Para exibir os imports corretos do HttpClient no vs code, primeiro temos que importar o módulo dele la em app.module.ts,
    para que nossa aplicação identifique suas dependencias, seus outros imports.

1 - Importamos o modulo em app.module.ts import { HttpClientModule } from '@angular/common/http';
2 - importamos em nosso component import {HttpClient} from '@angular/common/http';

import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
//codigo
})
export class AppComponent {

  constructor(http: HttpClient){
    console.log(http);
  }

}

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],


----- Fazendo uma requisicao com HttpClient -----

    export class AppComponent {

        photos: Object[] = [];

        constructor(http: HttpClient){
            http
                .get<Object[]>('http://localhost:3000/flavio/photos')
                .subscribe(photos => this.photos = photos);
            
        }

    }

    Exibindo o erro:
        http
            .get<Object[]>('http://localhost:3000/flavio/photosx')
            .subscribe(
                photos => this.photos = photos,
                err => console.log(err.message)
            );

------------------- Service -------------------

Quando criamos um servico, utilizamos o decorator @Injectable({ providedIn: 'root' }), para falar pra ele
    disponibilizar esse servico em todo nosso projeto(nesse caso).

Criamos services, dentro dos components, exemplo:
    photo/
        photo.component.html
        photo.component.ts
        photo.service.ts <- aqui nomeamos dessa forma.

Se eu crio uma classe service, chamo ela em outra classe, o angular n vai conseguir executar o servico,
    precisamos ir até a classe e injetar com decorator, para que ele identifique e execute o servico, exemplo:

MEU SERVICO:

    import { HttpClient } from "@angular/common/http";
    import { Injectable } from "@angular/core";

    const  API = 'http://localhost:3000';

    @Injectable({ providedIn: 'root' })
    export class PhotoService{

        constructor(private http: HttpClient){}

        listFromUser(user: string){

            return this.http
                .get<Object[]>(API + '/flavio/photos');
        }
    }

CLASSE QUE CONSOME ESSE SERVICO:

    import { Component } from '@angular/core';
    import { PhotoService } from './photos/photo/photo.service';


    @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
    })
    export class AppComponent {

    photos: Object[] = [];

    constructor(photoService: PhotoService){ 
        
        photoService
        .listFromUser('flavio')
        .subscribe(photos => this.photos = photos);
    }

    }

------------------- BLINDANDO A API -------------------

Uma API sem essa blindagem, n contem AUTOCOMPLETE quando retornado os dados da API, dificultando sua implementacao,
    e caindo em produtividade, para resolver isso, vamos criar uma INTERFACE para a API, e lá passamos tudo oq
    a API DEVE receber.

INTERFACE:
    export interface Photo{
        id:number;
        postDate:Date;
        url:string;
        description:string;
        allowComments:boolean;
        likes:number;
        comments:number;
        userId:number;
    }
SERVICO DA API:
    export class PhotoService{

        constructor(private http: HttpClient){}

        listFromUser(user: string){

            return this.http
                .get<Photo[]>(API + '/'+user+'/photos'); // Tipo o retorno da API, como INTERFACE Photo
        }
    }
CLASSE que consome a API:
    export class AppComponent {

    photos: Photo[] = [];

        constructor(photoService: PhotoService){
            
            photoService
            .listFromUser('flavio')
            .subscribe(photos => {
                console.log(photos[0].userId); // Aqui agora eu consigo dar ponto e ver todas as propriedades de photos
                this.photos = photos
            });
        }

    }

IMPORTANTE!!!!!
Consequencia, agora eu tenho um AUTOCOMPLETE na minha API, e MAIS, exemplo:
    se um dia a propriedade mudar da minha API, por exemplo userId não é mais userId, agora ele é somente user,
    vou ir até a minha INTERFACE ir até a propriedade userId clico com o direito nela e seleciono Rename Symbol,
    coloco user aperto ENTER e pronto, todo o restante do meu código que ANTES implementava como userId, agora
    passa a implementar como user somente.

------------------- Ciclo de vida de um component -------------------

1 - No constructor deve conter apenas para injeção de dependência.
2 - E qualquer lógica que queiramos executar será colocada em uma fase do ciclo de vida
    que todo componente Angular possui.

    lifecycle hook / ciclo de vida
1 - ngOnInit -> é chamado depois que Angular inicializou todas as propriedades ligadas a dados de uma diretiva. 
                    Defina um método ngOnInit () para manipular quaisquer tarefas de inicialização adicionais.
        ngOnInit(): void {
            this.photoService
                .listFromUser('flavio')
                .subscribe(photos => {
                    console.log(photos[0].userId);
                    this.photos = photos
                });
        }

------------------- Gerando components/modulos via console -------------------

    IMPORTANTE O comando ng generate SEMPRE comeca a pegar a partir da pasta APP
    entao vc vai colocar tudo que está DENTRO DELA.

    SINTAX: ng generate component nomeDaPasta

    app
      photos

    ng generate component photos/photo-list -> estou criando dentro de app/photos um diretorio photo-list
                                                    com todos os seus components e chamadas.

    ng generate module errors -> ira gerar um modulo dentro da pasta errors

------------------- DIRETIVAS ANGULAR -------------------

Para importar as diretivas do angular, importe em seu modulo o CommonModule, o BrowserModule já importa esse modulo, 
    dentro dele, por isso n precisamos importar CommonModule em app.component.ts

O CommonModule possui todas as diretivas básicas como NgIf, NgFor, NgForOf etc

*ngFor -> 
    <ap-photo
        *ngFor="let photo of photos" 
        [url]='photo.url' 
        [description]='photo.description'>
    </ap-photo>

------------------- SPA ROTAS -------------------

1- Criamos o arquivo app.routing.module.ts em app/
2- Dentro de app.routing.module.ts fazemos nossas configurações:
    Devemos importar o Routes de @angular/router, para tipar nossa constante routes,
    caso n fizer isso, n dara erro se trocar o path por pat por exemplo, gerando um erro no link, na hr da 
    execucao.
    Devemos importar o RouterModule para linkar nossas rotar com o modulo de rotas, fazemos isso
        dessa maneira: imports: [ RouterModule.forRoot(routes) ].
    Exporto RouterModule, pois em app.component.html tem um component q DEPENDE dele para funcionar, chamado de
        <router-outlet></router-outlet>, ele depende das diretivas de RouterModule.
3- Vamos ate app.module.ts e importamos nosso modulo de rotas AppRoutingModule


    import { NgModule } from '@angular/core';
    import { Routes, RouterModule } from '@angular/router'

    import { PhotoListComponent } from './photos/photo-list/photo-list.component';
    import { PhotoFormComponent } from './photos/photo-form/photo-form.component';

    const routes: Routes = [
        { path: 'user/flavio', component: PhotoListComponent },
        { path: 'p/add', component: PhotoFormComponent }
    ];

    @NgModule({
        imports: [ RouterModule.forRoot(routes) ],
        exports: [ RouterModule ]
    })
    export class AppRoutingModule {}

----- pagina inicial -----

Se quisermos fazer um component ser carregado na pasta raiz, a rota deve ficar assim:
{path: '', component: SigninComponent} -> o path vazio seria a mesma coisa que localhost:4200(raiz)

----- pagina 404 -----

Se quisermos redirecionar pra uma pagina especifica quando n existir determinada página, fazemos o seguinte:

    const routes: Routes = [
        { path: 'user/flavio', component: PhotoListComponent },
        { path: 'p/add', component: PhotoFormComponent },
        { path: '**', component: PhotoListComponent }
    ];

Estou dizendo que qualquer diretorio q n foi definido em path, carrega o component PhotoListComponent


----- Deixando a rota dinamica -----

    { path: 'user/:userName', component: PhotoListComponent }
        Estou dizendo que dps de user/ pode vir qualquer coisa, que ele n vai dar como nao encontrado.

    Lá em nossa API, fazemos o seguinte:
        ngOnInit(): void {

        const userName = this.activatedRoute.snapshot.params.userName; // Recebo o valor definido na url user/:userName

        OBS: activatedRoute -> indica a ROTA ativada naquele momento
        
        // Passo esse valor para o listFromUser
        this.photoService
            .listFromUser(userName)
            .subscribe(photos => this.photos = photos);
    }

    E lá no meu servico, eu executo a acao, com base no nome passado:
    
        listFromUser(userName: string){
            
            return this.http
                    .get<Photo[]>(API + '/'+userName+'/photos');
        }

----- Lidando com dados assincronos -----

    Usamos implements OnChanges

    ngOnChanges(changes: SimpleChanges) -> 
        Este método recebe como parâmetro todas as possíveis mudanças das inbound properties do nosso componente. 
        Tais mudanças são do tipo SimpleChanges, que importaremos de angular/core. Caso haja alguma mudança, 
        uma propriedade com mesmo nome da inbound property que sofreu a mudança será adicionada dinamicamente. 
        Se não houver mudança, tampouco haverá propriedade.

    ngOnChanges(changes: SimpleChanges){
        if(changes.photos)
            this.rows = this.groupColumns(this.photos);
    }

    changes.photos -> contem o valor antigo e o novo, caso tenha um novo valor ele retorna true.



------------------- Pipes ANGULAR -------------------

suponhamos q temos uma variavel nome na classe app.component.ts
    app.component.ts:
        nome = 'nicolas';

na view de app.component.html, vamos fazer o pipe:
    app.component.html
        {{ nome | uppercase }} // nicolas

O angular, possui diversos pipes, mas podemos criar nossos proprios PIPES também.

----- Criando seu proprio pipe ANGULAR -----

IMPORTANTE, UM Pipe tambem precisa ser declarado.

<div class="text-center mt-3 mb-3">
    <form>
        <input
            class="rounded"
            type="search"
            placeholder="search..."
            autofocus
            (keyup) = "filter = $event.target.value">
    </form>
</div>
{{ filter }}
<ap-photos  [photos]="photos | filterByDescription: filter"></ap-photos>

- Estou passando uma lista de fotos em photo-list-component.ts
- Fazendo uma logica para filtrar essa lista de fotos, DEACORDO COM o filter.
- pego o filter do `back-end`.

--- Criando a classe PIPE ---

@Pipe({ name: 'filterByDescription' })
export class nomeDaClasse implements PipeTransform{

    transform(value: number, ...args: string) // value será o valor requerido, args, sao os parametros passados.
}

[photos]="photinhas | filterByDescription: filter" -> photinhas = requerido, filter = params passados.

------------------- Resolver Angular -------------------

Ele é ativado ANTES de um componente ser carregado na página, isso é, ANTES dele carregar o componente,
ele procura no app.routing se existe algum resolver(pra resolvelo, e só depois carregar o componente)

Exemplo de resolver:
{
    path: 'user/:userName',
    component: PhotoListComponent,
    resolve: {
        photos: PhotoListResolver
    }
},

-- Criando um resolver --

    IMPORTANTE, Todo resolver deve ter seu decorator Injectable, assim como os services.
    @Injectable({ providedIn: 'root' })
    export class PhotoListResolver implements Resolve<Observable<Photo[]>>{

        constructor(private service: PhotoService) {}

        resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<Photo[]>{

            const userName = route.params.userName;
            return this.service.listFromUser(userName);
        }
    }

    esse resolver, vai devolver a lista de fotos para a phot-list.component.ts

    Crio a ligacao da rota com o dado em app.routing.module.ts:

    {
      path: 'user/:userName',
      component: PhotoListComponent,
      resolve: {
          photos: PhotoListResolver
      }
    }

    em PhotoListComponent eu recebo ele com base na proriedade devinida em app.routing.module.ts:

     constructor(private activatedRoute: ActivatedRoute){}

    ngOnInit(): void {

        this.photos = this.activatedRoute.snapshot.data.photos; // snapshot.data eu acesso as propriedades de resolve de app.routing.module.ts
    }
    
------------------- Debounce com  RXJS no Angular -------------------

    Vamos utilizar uma lib muito boa, chamada RxJS, que serve para trabalhar com codigos asyncronos e mais..

    import { debounceTime } from 'rxjs/operators';
    import { Subject } from 'rxjs';

    export class PhotoListComponent implements OnInit {

        filter: string = '';
        debounce: Subject<string> = new Subject<string>();


        ngOnInit(): void {
            this.debounce
            .pipe(debounceTime(300)) // somente apos 300ms o valor passado em next na view, será enviado para subscribe
            .subscribe(filter => this.filter = filter);
        }

        ngOnDestroy(): void {
            this.debounce.unsubscribe(); // precisamos fazer isso, pois caso o usuário saia da pagina, o Subject pode ficar alocando memoria, e pode dar erro de memoria futuramente.
        } // problema conhecido por memory leak!
    }

    VIEW:

        <form>
            <input
                class="rounded"
                type="search"
                placeholder="search..."
                autofocus
                (keyup) = "debounce.next($event.target.value)">
        </form>


------------------- Como fazer if / else Angular -------------------

*ngIf="condicao; else exibeOutraCoisa" -> no caso essa outraCoisa seria o ng-template q eu defini atravez de #nomeDaOutraCoisa

<div class="text-center" *ngIf="hasMore; else messageTemplate">
    <button class="btn btn-primary">Load more</button>
</div>
<ng-template #messageTemplate>
    <p class="text-center text-muted">No more data to load</p>
</ng-template>

------------------- Como colocar o conteudo de outro template no seu? e Angular -------------------

    Com a diretiva <ng-content></ng-content> conseguimos fazer isso, exemplo abaixo:

        card.component.ts:
            <div class="card border-light text-center">
                <h4 class="card-header">{{ title }}</h4>
                <div class="card-block text-justify">
                    <ng-content></ng-content> <-- tudo q tiver dentro de card
                </div>
            </div>

        photos.component.ts
        <ap-card> <- card.component.ts
            <ap-photo
                [url]='photo.url' 
                [description]='photo.description'>
            </ap-photo>
            <div class="text-center p-1">
                <i aria-hidden="true" class="fa fa-heart-o fa-1x mr-2"></i>{{ photo.likes }}
                <i aria-hidden="true" class="fa fa-comment-o fa-1x mr-2 ml-2"></i>{{ photo.comments }}
            </div>
        </ap-card> 

    Estou dizendo que tudo que ficar dentro de <ap-card>, irá entrar na minha diretiva <ng-content>

------------------- SubModulos Angular -------------------

Criar submodulos, é uma boa pratica, pois alem de mostrar oq cada submodulo faz, vc divide bem as tarefas.

exemplo de criação de submodulos:
    photos/
        photo/
            photo.module.ts // submodulo de photos.module.ts
        photo-list/
            photo-list.module.ts // submodulo de photos.module.ts
    photos.module.ts

------------------- Data binding /  Event binding -------------------

[] -> O dado vem da fonte de dados para o template ( do ts para o html )
() -> O dado vem do template para a fonte de dados ( do html para o ts )

------------------- Change Detection -------------------

    Com .push o mecanismo de change detection do angular n funciona, precisa passar uma nova referencia
        this.photos.push(...photos);
    O codigo correto seria:
        this.photos = this.photos.concat(photos);

------------------- Output property -------------------

Como criar uma Output property?

@Output() onTyping = new EventEmitter<string>();

<input
    class="rounded"
    type="search"
    placeholder="search..."
    autofocus
    (keyup)="debounce.next($event.target.value)"
    [value]="value">

<ap-search 
  (onTyping)="filter = $event">
</ap-search>

this.debounce
      .pipe(debounceTime(300))
      .subscribe(filter => this.onTyping.emit(filter));

conforme o usuário digita, o debounce.next envia o valor do que foi digitado, para o this.debounce,
dps de 300ms, eu dou um subscribe e pego o valor digitado, passo para a minha Output e emito esse valor,
apos emitir o valor, ele é passado para o meu $event, que por Consequencia o meu filter recebe o $event,

------------------- Criando a primeira Diretiva -------------------

OBS: O Directive do angular segue o padrao de seleção  CSS attribute selector, então podemos fazer assim:
    @Directive({
        selector: '[appHighlight]'
    })
        OU
    @Directive({
        selector: 'button[type]'
    })

IMPORTANTE!! ->
    Sempre que criar uma diretiva, faça a declaração dela em declarations, como se fosse um
        componente.
    Sempre nomeie uma diretiva com o padrao de prefixo, exemplo: [appHighlight]
    Certifiquece de não nomear a diretiva como [ngHighlight], pois o prefixo ng é reservado
    pelo angular, e isso pode causar bugs dificeis de diagnosticar.
    Voce usa o ElementRef no constructor para injetar uma referencia ao elemento que voce aplicou
        o appHighlight
    ElementRef concede acesso direto ao elemento do DOM por meio da sua propriedade nativeElement.

Nesse caso, iremos criar uma diretiva, para que todo component q tiver essa diretiva,
tenha o efeito de hover ao passar o mouse em cima.

Para criarmos uma diretiva, devemos fazer dessa maneira.

darken-on-hover.directive.ts:

    import { Directive } from '@angular/core';

    @Directive({
        selector: '[apDarkenOnHover]',
    })
    export class DarkenOnHoverDirective { }

// O seletor criado serve para indicar o nome da diretiva

 <div *ngFor="let photo of cols" class="col-4" apDarkenOnHover>

 Aqui colocamos aonde queremos nossa diretiva, direto no html que queremos.

 -- Eventos Javascript --

 Utilizamos o decorator @HostListener('nomeDoEvento')

 Exemplo:
    @HostListener('mouseover')
    darkenOn() {
        console.log('darkenOn');
    }
// Ao passar o mouse em cima do elemento que possui a diretiva, ele irá disparar a funciona
// correspondente

-- Acessando e estilizando via component -- 

    constructor(
        private el: ElementRef, // Referencia ao elemento da diretiva
        private render: Renderer // atributo q mexe com estilizacao e muito mais.
        ){}

    @HostListener('mouseover')
    darkenOn() {
        this.render.setElementStyle(this.el.nativeElement, 'filter', `brightness(${this.brightness})`);
        // passo para ele o elemento que quero estilizar, e qual estilizacao eu quero dar, e o valor.
    }

------------------- Selecionando Elementos -------------------

    Como selecionar elementos?
        Utilizamos o @ViewChild('nomeDoMarcadorFeitoNoElemento')
    Exemplo de uso:
    TS:
        @ViewChild('userNameInput') userNameInput: ElementRef<HTMLInputElement>;
    HTML: 
        <input
			#userNameInput // Aqui definimos o marcador, e la no TS, chamamos ele no @ViewChild
			class="form-control" 
			placeholder="user name" 
			formControlName="userName" 
			autofocus>

------------------- Validando formulario -------------------

Utilizamos as validacoes via angular, pois a validacao padrao do html5, não é integrada com o framework
então, para aproveitar todo o poder q o framework nos fornece, devemos validar via Angular.

Utilizando o ReactiveFormsModule.

Model Driven Forms ->, cuja regra de validação ficará no componente, e não no template.

-- Iniciando --

Após importar o ReactiveFormsModule, voce tera acesso a varias classes e diretivas desse pacote.

para linkar com o formulario temos q ter uma propriedade do tipo FormGroup.

Para termos acesso aos campos dos formularios, precisaremos de um construtor de formulario,
ele é chamado de FormBuilder, voce o declara em seu construtor.

    export class SigninComponent {


    loginForm: FormGroup; // consigo injetar mais de um campo no FormGroup

    constructor(private formBuilder: FormBuilder){} // ele é oq faz o formulario existir.

    }

this.loginForm = this.formBuilder.group({
    userName: ['', Validators.required],
    password: ['', Validators.required]
});

o codigo acima eu estou definindo os campos q tenho, seus valores, e suas validacoes,

porem para que seja valido esses campos, eu tenho q identificalos no html
    <form [formGroup]="loginForm">
        <input formControlName="userName">
Agora sim, fiz o binding de formGroup com loginForm, e de linkei userName no html com
    userName no arquivo .ts

Agora para acessar um valor do formulario basta fazer:
    this.loginForm.get('userName').value
    da pra fazer diversas outras coisas

-- Como limpar um formulario? --

this.loginForm.reset(); -> limpa todos os campos definidos em this.formBuilder.group.

------------------- Navegando entre paginas -------------------

Para redirecionar o usuário para determinada tela faca o seguinte.

contructor(private router: Router){} -> declare a classe Router, para termos acesso as rotas.

OBS: O Router é disponibilizado pelo RouterModule, entao se quiser ter acesso a ele no seu component,
tera q importar o RouterModule.

Em seguida, simplesmente mostre qual caminho voce quer acessar:
    -- navigateByUrl --
        this.router.navigateByUrl('user/' + userName).
    -- navigate --
        this.router.navigate(['user',userName]).

Qual a diferenca entre as duas?, uma voce tem que ficar concatenando a url,
    a outra voce só passa a url num vetor separando por virgula.

OBS: é mais interessante usar o .navigate(), pois quando for uma rota gigante, vc n 
    precisara ficar concatenando a rota inteira.


.navigateByUrl -> aceita uma url para redirecionar.

------------------- Selecionando elementos sem ser por diretivas. -------------------

colocamos uma variavel de template:
    <input #userNameInput>
E no codigo ts:
    @ViewChild('userNameInput') userNameInput: ElementRef<HTMLInputElement>;
        referenciamos o #userNameInput em ViewChild, agora o ElementRef, tem sua
        referencia de elemento, que no caso é a tag input.

------------------- Deteccao de plataformas, resolvendo server side rendering -------------------

import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

@Injectable({ providedIn: 'root' })
export class PlatformDetectorService {

  // INJETO UM VALOR (O ID DA PLATAFORMA) na variavel platformId, se for browser vai retornar browser.
  // sem eu nem precisar definir valor, pois estou INJETANDO UM VALOR.
  constructor(@Inject(PLATFORM_ID) private platformId: string){} 

  // Chamo uma funcao do proprio angular, que espera um platformId,
  // e que verifica se a plataforma é browser ou nao.
  isPlatformBrowser(){
    return isPlatformBrowser(this.platformId);
  }
}

------------------- Pegando o token do back-end via ajax -------------------

authenticate(userName: string, password: string){
    return this.http
      .post(
        API_URL + '/user/login', 
        { userName, password },
        {observe: 'response'}
      )
      .pipe(tap(res: HttpResponse<Object> => {
        const authToken = res.headers.get('x-access-token');
        console.log(authToken);
      }));
  }


  OBS: O tap, servirá como um intermediador entre o envio da resposta, para quem solicitou a requisicao,
    e para quem vai precisar do token por exemplo, ai nao precisamos em cada classe,
    pegar esse token, ao interceptar essa requisicao, com o tap conseguimos extrair esse valor.
  OBS: Se der erro na resposta ao acessar res.headers, é pq vc n definiu o observe como response.

para conseguir ter acesso aos headers da nossa requisicao, devemos setar a configuracao de observe: "response",
assim ele entende que eu quero todos os dados da requisicao, e nao apenas o body.

Bom vamos lá, devemos usar o tap() um operators do rxjs, ele nos auxiliara em pegar o dado de retorno do back,
juntamente com o .pipe, que vai fazer essa conexao entre a requisicao e resposta dela, e a manipulacao dessa resposta
atravez do tap.


------------------- Operadores novos a se estudar -------------------

!! -> mudanca de estado.
    EXEMPLO:
        nome = 'Nicolas';
        sobrenome = '';

        !nome -> vai retornar false, pois antes a variavel tinha algo escrivo(isso é, era TRUE), ai eu neguei e virou falso
        !!nome -> retorna true, pois ele deixou falso (pois tinha caracter entao era true, ai colocou uma ! ficou falso), e depois colocou outra !, ai o falso virou true.
        !sobrenome -> vai ser true (pq antes n tinha nada, entao era falso com ! virou true)
        !!sobrenome -> vai ser false

pode-se utilizar isso num caso como esse:
    hasToken(): boolean{
        return !!this.getToken();
    }

// ali eu pego uma string q é o token, porem tenho q ter um retorno booleano, ai eu nego duas vezes, pq quando
// vc nega, oq era string / null / undefined, vira booleano.

algo?.fazIsso -> oq é essa interrogação.

------------------- Segurança do token -------------------

O token é gerado no padrão JWT (J*son *Web Token)

podemos descriptografar o token em qualquer site de descriptografia de JWT, porem de nada adianta,
pois la no back-end, vc tem uma palavra chave para verificar a veracidade do token,
e caso essa palavra chave n bata com o token, n adianta adultera-lo, q la no back-end sera recusado.

porem... vc n deve colocar dados sensiveis junto body, pois a pessoa vai conseguir ter acesso a isso.

  -- payload JWT(Json Web Token) --
    Para trabalhar com o dado criptografado, teremos que pegar a criptografia, descriptografar,
    e trabalhar com o payload que essa criptografia nos disponibiliza.( que seria o body
    os dados que realmente importam)

  private decodeAndNotify(){
    // pego o token, passo para o jtw_decode, ele descriptografa
    const token = this.tokenService.getToken();
    const user = jtw_decode(token) as User; // fazendo o cast do valor recebido para o tipo User
    this.userSubject.next(user);
  }

  //esse metodo faz a descriptografia e adiciona o valor em userSubject, farei outro metodo
      para retornar esse userSubject como um Observable.

  getUser(){
    return this.userSubject.asObservable();
  }

  // Nesse getUser eu peço para retornar o userSubject como um Observable, para que quem
    consuma ele, possa dar um subscribe. (e tb ter todos os beneficios de um Observable)


------------------- Casting TypeScript -------------------

  Nova maneira de fazer Casting, pode se fazer assim:
  const user = <User>jtw_decode(token);
  const user = jtw_decode(token) as User;
  // ambas as formas fazem o cast, mas lembre-se esse cast é feito apenas no compiler, e n runtime cast
  //Just remember that this is a compile-time cast, and not a runtime cast.
  const user = jtw_decode(token) as User; // fazendo o cast do valor recebido para o tipo User





------------------- BehaviorSubject -------------------

o Behavior Subject, é utilizado quando uma pagina executa depois que um servico já foi ativo.

diferenca entre Subject e BehaviorSubject

o Subject vc pode deixar valores em cache e user em outros componentes esses valores.

o BehaviorSubject faz a mesma coisa, com um adicional.

SE o seu servico carregar primeiro que o componente da pagina, com o Subject apenas n sera possivel,
obter o valor do Subject feito em .next, porque o servico ja vai ter dado o next, e a pagina q vai
ser carregada DEPOIS, vai ficar esperando... iai cade meu next? cade? pra sempre e n vai identificar o valor.

Ja o BehaviorSubject ele quarda o valor do next, e fica vendo quem da subscribe, quem der subscribe ele fornece
    o valor que ele guardou, ja o Subject, n fica vendo quem da subscribe.


------------------- PIPE ASYNC -------------------

private userSubject = new BehaviorSubject<User>(null);

user$: Observable<User>;

<div *ngIf="(user$ | async) as user; else login">
    <i class="fa fa-user-circle"></i>
    <a>{{ (user.name)}}</a>
</div>

O PIPE ASYNC SE ENCARREGA DE DUAS COISAS: // (user$ | async) as user

    a primeira é que ele mesmo da o subscribe pega o valor pra vc e passa pra variavel q vc definir em as user (nesse caso)
    a segunda coisa é que ele ja se encarrega de destruir o elemento pra voce, seja com BehaviorSubject ou Subject


------------------- PROTECAO DE ROTAS -------------------

Para fazer protecao de rotas usamos os .guard junto as definicoes de rotas, segue um exemplo
estou inpedindo q um usuario logado consiga acessar a tela de login.


auth.guard.ts:
    import { Injectable } from '@angular/core';
    import { UserService } from '../user/user-service';
    import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
    import { Observable } from 'rxjs';

    @Injectable({ providedIn: 'root' })
    export class AuthGuard implements CanActivate{
    
    constructor(
        private userService: UserService,
        private router: Router){}
    
    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
        if(this.userService.isLogged()){
        this.router.navigate(['user', this.userService.getUserName()]);
        return false;
        }
        return true;
    }
    
    }
app.routing.module.ts:
    const routes: Routes = [
    {
        path: '', 
        component: SigninComponent,
        canActivate: [AuthGuard] // aqui em canActivate, eu falo qual guard entrará, para fazer a protecao da rota.
    },

E essa classe AuthGuard, que ira conter toda a logica necessária para fazer a protecao dessa rota.

------------------- A diretiva RouterLink -------------------

Ela precisa de RouterModule para funcionar.

nunca faça esse tipo de redirecionamento em uma SPA, pois essa forma que vou mostrar faz com que,
todos os arquivos sejam loadados novamente, e n é isso que uma SPA faz.

<a href="/"> <- esse tipo de redirecionamento tras todo um problema de performance, fazendo com q sua SPA
    recarregue todas suas dependencias novamente.

O CORRETO É UTILIZAR A DIRETIVA RouterLink.
    <a [routerLink]="['']"> -> aqui sua SPA está a salva, ele n recarrega todas as dependencias da pagina
        novamente, apenas a redireciona para a tela de login.

O routerLink funciona igual o .navigate
    exemplo:
        [routerLink]="['user', 'flavio']" -> vai redirecionar para http://localhost:4200/user/flavio


------------------- Validacao de Formularios ANGULAR -------------------

    IMPORTANTE!: Os Validators, quando se usa mais de 1, é necessário incluir eles
        dentro de um array, caso contrario co codigo irá gerar um erro.

    O Angular fornece, varios validadores para formularios, sendo eles:
    Validators.required, -> aqui vc diz que o campo é obrigatorio
    Validators.pattern(/^[a-z]+[0-9]*$/), -> aqui vc define um comportamento padrao que o campo deve seguir
    Validators.minLength(2), -> -> aqui vc defini a quantidade de caracteres minimos para o campo
    Validators.maxLength(30) -> aqui vc defini a quantidade de caracteres maximos para o campo

    Exemplo de uso:
      ARQUIVO.TS:
        // estou dizendo que o campo userName, vai começar em branco, e vai ter algumas,
        // validacoes
        this.signupForm = this.formBuilder.group({
            
            userName: ['',
                [
                    Validators.required,
                    Validators.pattern(/^[a-z]+[0-9]*$/),
                    Validators.minLength(2),
                    Validators.maxLength(30)
                ]
            ]
        });

      ARQUIVO.HTML:
        <div class="form-group">
            <input formControlName="userName" placeholder="user name" class="form-control">
            <ap-vmessage
                *ngIf="signupForm.get('userName').errors?.required"
                text="user name is required!">
            </ap-vmessage>
            <ap-vmessage
                *ngIf="signupForm.get('userName').errors?.pattern"
                text="Must be lowercase">
            </ap-vmessage>
            <ap-vmessage
                *ngIf="signupForm.get('userName').errors?.minlength"
                text="Minimun length is 2">
            </ap-vmessage>
            <ap-vmessage
                *ngIf="signupForm.get('userName').errors?.maxlength"
                text="Maximum length is 30">
            </ap-vmessage>
        </div>

------------------- Criando nosso próprio validador no Angular -------------------

Podemos criar uma classe que contem os validadores, OU criar uma funcao em um arquivo
    a parte e exportar ela.

CRIANDO:
    lower-case.component.ts:
    import { AbstractControl } from "@angular/forms";

    // Todo validator precisa receber uma classe AbstractControl como parametro
    export function lowerCaseValidator(control: AbstractControl){

        // Verifico se o valor está em branco E se o valor NAO SEGUE minha expressao regular 
        if(control.value.trim() && !/^[a-z0-9_\-]+$/.test(control.value)){
            return { lowerCase: true }; // retorno a chave necessária para conseguir acessar no formulario
        }

        return null; // retorno null, isso é, está tudo ok.
    }
    
    -- Incluindo o validador no meu codigo --
    TS:
        userName: ['',
            [
                Validators.required,
                lowerCaseValidator
            ]
        ],
    HTML:
        <ap-vmessage
            *ngIf="signupForm.get('userName').errors?.lowerCase" // AQUI devemos chamar o nome igual definimos no retorno da funcao lowerCaseValidator
            text="Must be lowercase">
        </ap-vmessage>

------------------- Validação assincrona Angular -------------------

Validacao ASSINCRONA acontece no terceiro parametro do formBuilder:

this.signupForm = this.formBuilder.group({
    email: [
        '', // 1º Parametro, comeca o formulário em branco.
        [
            Validators.required, // 2º Parametro, faz a validacao syncrona
            Validators.email // 2º Parametro, faz a validacao syncrona
        ],
        this.userNotTakenValidatorService.checkUserNameTaken() // 3º Parametro, faz a validacao sincrona
    ]
});

Criando um servico para verificar se o usuário ja existe no banco:

    import { Injectable } from "@angular/core";
    import { HttpClient } from "@angular/common/http";

    const API_URL = 'http://localhost:3000/';

    @Injectable({ providedIn: 'root' })
    export class SignUpService{

        constructor(private http: HttpClient){}

        // Verifica se o usuário já existe na base de dados
        checkUserNameTaken(userName: string){
            return this.http
            .get(API_URL + 'user/exists/' + userName);
        }
    }

O GRANDE PROBLEMA DISSO TUDO, é que nosso validador de formulario, 
    nao suporta injecao de dependencia.

Para isso, podemos arrumar outra maneira, q seria criar um Servico, e esse servico
    vai ser nosso validador.

IMPORTANTE, uma validacao assincrona não retorna nem null, nem um Objeto javascript,
    ele retorna um Observable.

    entao n pode ser mais control.value, agora deve ser control.valueChanges -> ele retorna um
        Observable
        checkUserNameTaken(){
            return (control: AbstractControl) => {

            return control.valueChanges;
            }
        }

    checkUserNameTaken(){
        return (control: AbstractControl) => {

        return control
            .valueChanges
            .pipe(debounceTime(300))
            .pipe(switchMap(userName => {
                return this.signUpService.checkUserNameTaken(userName);
            }));
        }
    }

    Usamos o switchMap para ele parar de ouvir o fluxo anterior,
    ai ele troca(switch) para o fluxo do checkUserNameTaken

    checkUserNameTaken(){
        return (control: AbstractControl) => {

        // Primeiro eu pego o valor do formulario, dps de 300 milisegundos,
        // eu processo ele no switchMap(ele para de ouvir o debounce e comeca a ouvir o checkUserNameTaken)
        // dps esse metodo vai retornar um booleano, porem para a validacao de formulario,
        // eu preciso de um null, ou de um objeto javascript, ai eu faço a transformacao desse dado,
        // utilizando o map do rxjs
        // porem, o sistema de validacao de formulario ainda n vai funcionar, pois ele n sabe quando
        // essa operacao terminou, ate aqui ele vai retornar um observable, e ele sabe dar um subscribe,
        // porem n sabe ver quando terminou, pra isso vamos utilizar mais um operador do rxjs,
        // chamado first
        return control
            .valueChanges
            .pipe(debounceTime(300))
            .pipe(switchMap(userName => this.signUpService.checkUserNameTaken(userName))) // retorna um boolean
            .pipe(map(isTaken => isTaken ? { userNameTaken: true } : null)) // retorna o valor que realmente interessa
            .pipe(first()); // esse first() pega um unico valor, isso é, como agt fez com debounce

        // o usuario vai estar digitando: lalalala, e quando finalizar o debounce, o first pega
        // o primeiro valor, que nesse caso é o lalalala, e envia.
    }



    MUITO CUIDADO, Ao trabalhar com validacoes assincronas, sempre coloque:
    esse .pending, fica verificando se tem alguma validacao assincrona processando, pois
        enquanto tiver uma validacao assincrona pendente, o formulário estará inválido.

        [disabled]="signupForm.invalid || signupForm.pending"
        <button [disabled]="signupForm.invalid || signupForm.pending">
            Register
        </button>

------------------- Submissão dos dados ANGULAR -------------------

    Para agilizar o processo de 'captação dos dados', voce pode utilizar o .getRawValue(),
    da classe FormGroup, assim ele junta todas as proprietades do formulario,
    e te devolve um objeto.
        exemplo:
            const newUser = this.signupForm.getRawValue(); -> retorna todos os campos do form em formato
                de objeto.
    feito isso, podemos fazer o que quisermos com os dados.

------------------- Rotas Filhas Angular -------------------

    Como fazer?
        Aqui vai um exemplo:
    HTML:
        <div class="container">
            <div class="row">
                <div class="col-md-6 mb-2">
                    <img class="img-fluid d-none d-sm-block"
                        src="/assets/img/home.jpg" alt="Welcome">
                </div>
                <div class="col-md-6">
                    <router-outlet></router-outlet> // aqui eu falo que o component q tiver
                        // configurado em app.routing.module.ts vai ser carregado.
                        // Nesse caso seria os components que começam com ''(rota raiz)
                </div>
            </div>
        </div>
    CONFIGURANDO ROTAS PARA SUPORTAR ROTAS FILHAS em app.routing.module.ts:
        {
            path: '', // ele vai iniciar com Home component pois está com ''(raiz)
            component: HomeComponent,
            canActivate: [AuthGuard],
            children: [ // em children eu digo todas as rotas filhas de HomeComponent
                {
                    path: '', // e tambem iniciar com SigninComponent, pois tb está com ''(raiz)
                    component: SigninComponent,
                    canActivate: [AuthGuard]
                },
                {
                    path: 'signup', // aqui se ele for pra essa rota, vai acontecer na msm pagina
                    component: SignupComponent
                }
            ]
        }

------------------- Build do projeto ANGULAR -------------------

ng build --prod -> esse comando se encarrega de otmizar todo o seu projeto,
    e no final ele gera uma pasta dist com todo o conteudo otimizado.

chunk {0} runtime.a66f828dca56eeb90e02.js (runtime) 1.05 kB [entry] [rendered]
chunk {1} styles.294c92fb1e1373a98255.css (styles) 173 kB [initial] [rendered]
chunk {2} polyfills.8a61012ef5f13d508214.js (polyfills) 63.2 kB [initial] [rendered]
chunk {3} main.77c270a1f876790ec0b8.js (main) 368 kB [initial] [rendered]

Ao Final ele vai falar os principais arquivos otimizados.

Os arquivos com estilos globais ficam no styles, ou seja, o Bootstrap fica contido neste arquivo
E há um runtime, para que o Angular funcione
A pasta "alurapic" é a que deve ser colocada no servidor Apache, PHP, Java, e por aí vai

Caso você utilize Gmail, perceberá que as URLs possuem esta cerquilha entre barras, uma técnica datada. Antes do History API, se alterássemos a barra de endereços do navegador, a location inevitavelmente seria modificada, e o back end seria acessado, executando-se a requisição. Sabemos que isso não pode ser feito, e que esta mudança é apenas para efeito de rotas, para que o Angular detecte qual componente deve ser carregado.

Uma vez que o hash não dispara o carregamento na mudança do location, no back end, o Angular o intercepta e extrai a informação, um processo bem comum. Entretanto, para não usarmos este símbolo, além do navegador necessitar de suporte à History API, o back end cujo Angular é hospedado precisa estar programado para que qualquer requisição feita para ele devolva index.html.

Mas de que forma configuramos isso?
Depende do servidor em uso. Vamos supor que não queiramos ou saibamos fazer esta configuração, ou que estejamos utilizando algum servidor que não permite tais alterações. Basta ativarmos as rotas com hashtags que a aplicação funcionará sem este tratamento especial.

Para isso, no nosso arquivo de rotas (app.routing.module.ts), na parte de NgModule com RouterModule.forRoot(routes), passaremos um objeto JavaScript com a seguinte configuração:

@NgModule({
    imports: [
        RouterModule.forRoot(routes, { useHash: true } )
    ],
    exports: [ RouterModule ]
})

Assim, quando a página principal da aplicação é carregada, o # é colocado automaticamente. Esta é a solução com maior compatibilidade em relação aos navegadores, inclusive com aqueles que não suportam History API. Porém, é importante frisar que o Angular realiza testes somente com as duas últimas versões de qualquer navegador do mercado. Sendo assim, se a restrição de navegador é impactante no projeto, talvez o Angular não seja o framework adequado para uso.

------------------- Code splitting e Lazy Loading ANGULAR -------------------

IMPORTANTE: NUNCA CARREGUE O MODULO DO COMPONENT Q VC QUEIRA DEIXAR LAZY EM app.module, se n n faria sentido
pois ele carregaria junto as suas dependencias, pois o app.module carrega todas suas dependencias inicialmente

O angular carrega todos os seus components no arquivo
    chunk {3} main.77c270a1f876790ec0b8.js (main) 368 kB [initial] [rendered]
Como o projeto é pequeno está com poucos kb, mas tem projetos que chegam a 8MB, isso é ruim,
pois o angular é uma SPA, entao todos os seus components sao carregados no inicio.

para melhorar isso, vamos utilizar um padrao de projeto chamado Lazy Loading e Code splitting,
a ideia é q os components menos usados só carreguem quando o usuário clicar para ir na rota,
desse component.

Geralmente o pessoal verifica se o main passa de 300k(GZIPADO) caso passe ai, comeca o separacao
    do código.

Code splitting -> A separação do código nós chamamos de code splitting

Lazy Loading -> O carregamento dele nós chamamos de Lazy Loading

--- Organizando as rotas ---

primeiro criaremos um path raiz '', que vai redirecionar para a home, caso o usuário acesse ela.

pathMatch -> se eu digo que ele é full, então ele DEVE carregar APENAS a rota indicada no
    redirectTo.
    SE EU N FIZER pathMatch, ele pode querer fazer o match de outra rota e de outra, e por ai vai.

redirectTo -> ao pingar no path, definido, ele redireciona para a rota definida no redirectTo.

Para fazermos o lazy loading e code splitting, faremos o seguinte:

{
    path: '',
    pathMatch: 'full', // esse cara indica para o redirect, carregar EXATAMENTE a rota indicada.
    redirectTo: 'home'
  },
  {
    path: 'home', 
    component: HomeComponent,
    canActivate: [AuthGuard],
    children: [
      {
        path: '', 
        component: SigninComponent,
        canActivate: [AuthGuard]
      },
      {
        path: 'signup',
        component: SignupComponent
      }
    ]
  }

  Definido no app.routing.module.ts, vamos começar a fazer o lazy loading nos components que queremos.
    no caso o HomeComponent.
    vamos criar um arquivo chamado home.routing.module.ts

    const routes: Routes = [

        // definimos assim, pois a regra da rota vai ser dada em outro local
        // e deixando o path como principal como path: '', torna flexível as chamadas.
        {
            path: '',
            component: HomeComponent,
            canActivate: [AuthGuard],
            children: [
            {
                path: '', 
                component: SigninComponent,
                canActivate: [AuthGuard]
            },
            {
                path: 'signup',
                component: SignupComponent
            }
            ]
        },
    ];

    e lá em app.routing.module.ts, vamos remover os dados antigos que chamava home, vamos deixar
        apenas o path: 'home'
},
{
    path: 'home',
    loadChildren: './home/home.module#HomeModule' // aqui eu digo pra carregar as suas dependencias
},


aqui estou falando, ao cair no path raiz, redirecione apenas para home, e carregue suas dependencias

------------------- Organizando Servicos no ANGULAR -------------------

Bom, quando criamos servicos, temos q verificar aonde ele vai ser utilizado, se ele vai ser utilizado,
apenas no submodulo, n coloque o providedIn nele como root, pelo contrario, vc vai no submodulo
e em providers, vc adiciona ele, OU se apenas UM COMPONENT vai utilizado, vá até o componente,
em providers adicione sua service lá.

------------------- Interceptadores e envio de token ANGULAR -------------------

Automatizando envio de tokens atraves de Interceptadores do Angular,
Normalmente, em uma aplicação para fazer algumas validações no back-end,
precisamos enviar um token, e como isso se torna frequente, 
em vez de a cada componente solicitar o token dentro dele, podemos fazer um interceptador,
ele toda vez q houver uma requisição, vai verificar se o usuário está logado, e se estiver ele envia o token.

Implementando Interceptor:
    import { Injectable } from "@angular/core";
    import { HttpInterceptor } from "@angular/common/http";
    import { HttpRequest } from "@angular/common/http";
    import { HttpHandler } from "@angular/common/http";
    import { Observable } from "rxjs";
    import { HttpSentEvent } from "@angular/common/http";
    import { HttpHeaderResponse } from "@angular/common/http";
    import { HttpProgressEvent } from "@angular/common/http";
    import { HttpResponse } from "@angular/common/http";
    import { HttpUserEvent } from "@angular/common/http";

    @Injectable()
    export class RequestInterceptor implements HttpInterceptor {

        constructor(private tokenService: TokenService) {}

        intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpSentEvent
            | HttpHeaderResponse | HttpProgressEvent | HttpResponse<any> | HttpUserEvent<any>> {

                if(this.tokenService.hasToken()) { // verifico se ele tem token ( se tiver e pq ele ta logado )
                    const token = this.tokenService.getToken(); // pego o token
                    req = req.clone({ // Aqui eu clono o header, e incluo o meu header para enviar para o back-end o token
                        setHeaders : {
                            'x-access-token': token
                        }
                    });
                }
            return next.handle(req); // envio o header modificado.

        }
    }

    POREM, Para que tudo isso funcione, temos que fazer algumas configurações no modulo 
        em que o interceptor se encontra.

    core.module.ts:
        providers: [
            {
                provide: HTTP_INTERCEPTORS, // aqui eu provido o HTTP_INTERCEPTORS
                useClass: RequestInterceptor, // Classe q será usada toda vez q meu http for interceptado
                multi: true // pode ser que tenha mais de um interceptador, e ele vai delegando pro proximo
            }
        ]

E pronto, seu interceptor estará funcionando.

------------------- ERROS ANGULAR -------------------

    Quando voce trabalha com formularios no Angular, obrigatoriamente voce
    tem que ter o FormsModule importado.

    Isso acontece pq o Angular por padrao tenta colocar um Controlador De formulario
    pra vc, mas ele só consegue fazer isso se o FormsModule estiver  importado.

    para resolver isso, importe o FormsModule e o erro irá desaparecer.


------------------- SRM ESTUDO ANGULAR -------------------

---- MatDialog Service ----

    https://material.angular.io/components/dialog/overview

    é um servico de modal padrao do Angular, simples de usar.
    
    let dialogRef = dialog.open(UserProfileComponent, {
        height: '400px',
        width: '600px',
    });

---- ngClass ----

    https://angular.io/api/common/NgClass

    voce pode exibir uma classe de acordo com a condicao que vier do ts.
    exemplo:

    <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>

---- Diretivas do Angular ----
    [hidden]="condition" -> Esconde um elemento se a condição for verdadeira.
        exemplo: <span [hidden]="true">Meu Texto aqui</span>

--------- Propriedades ---------

elvis operator typescript ?

------------------- ESTUDO DOCUMENTACAO ANGULAR -------------------

-- HostListener --
 @HostListener -> Decorator que declara um evento DOM para escutar, e fornece um metodo
    manipulador para ser executado quando esse evento ocorrer.

Sintax: @HostListener('eventName', 'args')

**************************** DUVIDAS ANGULAR ****************************

ng build --base-href /myUrl/ -> oq faz? testando aqui ele apenas troca o diretorio raiz,
    em vez de ser www.google.com vai ser www.google.com/myUrl.

ng build --deploy-url -> URL onde os arquivos serão implantados(URL where files will be deployed)

ng build --prod -> Flag to set configuration to "prod".

mask no input? -> é do angular? do html?
    <input mask="00.000.000/0000-00">

------------------- Renderer2 VANTAGENS -------------------

NOTA: Renderer -> ele foi depreciado, pois existia um metodo que fazia com que tinhamos acesso,
    ao dom diretamente invokeElementMethod(): void, e esse cara fazia com que as coisas nao funcionacem,
    bem quando a aplicação fosse server side rendering.

Ao utilizar renderer ao invez de nativeElement, nós nos blindamos de manipular o dom diretamente,
e se estivermos trabalhando com server side rendering(angular universal e td mais), ele vai manter
tudo funcionando, vai abstrair toda a complexidade para nós.

EXEMPLO DE USO:

import { Directive, ElementRef, HostListener, Renderer, Input, Renderer2 } from '@angular/core';

@Directive({
  selector: '[apDarkenOnHover]'
})
export class DarkenOnHoverDirective {

  @Input() brightness = '70%';

  constructor(
    private el: ElementRef<HTMLElement>,
    private render2: Renderer2) {} // Aqui usei Renderer2 pois o Renderer foi depreciado. :)

  @HostListener('mouseenter')
  onMouseEnter(){
    this.render2.setStyle(this.el.nativeElement,'filter', `brightness(${this.brightness})`);
  } 

  @HostListener('mouseleave')
  onMouseLeave(){
    this.render2.setStyle(this.el.nativeElement,'filter', 'brightness(100%)');
  } 
}

------------------- entryComponents ANGULAR -------------------

Quando você adiciona componentes dinamicamente utilizando ViewContainerRef.createComponent(),
voce deve inclui-los em entryComponents do seu módulo.

Se você não listar um componente adicionado dinamicamente para entryComponentsvocê receberá
uma mensagem de erro um ataque de uma fábrica em falta porque Angular não terá criado um.

Isto é para componentes adicionados dinamicamente que são adicionados usando 
ViewContainerRef.createComponent(). Adicioná-los à entryComponents diz o compilador modelo 
off-line para compilá-los e criar fábricas para eles.

Os componentes registrados em configurações de rota são adicionados automaticamente ao 
entryComponentsbem, porque router-outlettambém usa ViewContainerRef.createComponent() 
para adicionar componentes encaminhado para o DOM.

Os componentes registrados em configurações de rota são adicionados automaticamente ao 
entryComponentsbem, porque router-outlettambém usa ViewContainerRef.createComponent() 
para adicionar componentes encaminhado para o DOM.

compilador molde offline (OTC) só constrói componentes que são efectivamente utilizadas. 
Se os componentes não são usados ​​em modelos diretamente o OTC não pode saber se eles 
precisam ser compilados. Com entryComponents você pode dizer a OTC também compilar estes 
componentes para que estejam disponíveis em tempo de execução.

------------------- ViewContainerRef -------------------

Quem receber esse cara, vai ter acesso ao view container of the element, isso vai hospedar
dinamicamente um componente.

Dicas: The <ng-template> element is a good choice for dynamic components because it doesn't render any additional output.

------------------- PERFORMANCE OnPush Strategy -------------------

    Ele só vai verificar mudanças automaticas nos seguintes casos:
        1 - The Input reference changes, porem se o dado do imput for Immutavel, ele nao vai alterar.

IMPORTANTE!
    Ao ativar a estratégia de OnPush, tem algumas regras.
    Ela só irá verificar mudanças automaticamente com valores primitivos (number,string,boolean,null, undefined)
    Caso for do tipo Array, Object, functions, será apenas um copy of a referencia
    (https://stackoverflow.com/questions/13104494/does-javascript-pass-by-reference/13104500#13104500),
    Ou seja, uma copia não consegue alterar o item original,
    Para forçar essa mudança de estado, voce deve passar uma nova referencia seja de Array, Objeto etc.

    Segue um exemplo:
    // Objeto Immutavel
    config = {
        position: 'top'
    };

    onClick() {
        this.config.position = 'bottom';
    }


------------------- ChangeDetectionStrategy SEM OBSERVABLES -------------------

IMPORTANTE As atualizações só pararam de acontecer para items 
MUTAVEIS(Alteráveis), os que sao IMUTÁVEIS(nasce com um valor morre com ele)
atualizará normalmente, exemplo, se eu passa a referencia de um novo vetor, ele alterará, pois
o angular entende que é um NOVO ELEMENTO.

Utilizamos essa estratégia para impedir que o Angular atualize a view TODA HORA QUE 
    ALGO MUDE, melhorando a performance.

Ao adicionar a estrategia ao componente "changeDetection: ChangeDetectionStrategy.OnPush",
As atualizações pararam de acontecer.(apenas para itens imutaveis)

Exemplo:
    Temos o pai:
        export class FoodComponent {

            foodNames = ['Bacon', 'Lettuce', 'Tomatoes'];

            constructor() { }

            addFood(food: string) {
                console.log('Food Adicionada');
                this.foodNames.push(food);
                // Passando uma NOVA REFERENCIA o Angular consegue detectar as alterações.
                // this.foodNames = [...this.foodNames, food];
            }
        }
    Temos o filho:
        @Component({
            selector: 'app-food-list',
            templateUrl: './food-list.component.html',
            changeDetection: ChangeDetectionStrategy.OnPush
        })
        export class FoodListComponent {

            @Input() foodNames: string[];

            constructor(private changeDetectionRef: ChangeDetectorRef) { }

            // Ao chamar essa função, o angular vai verificar o que foi mudado
            // e irá atualizar.
            update() {
                this.changeDetectionRef.detectChanges();
            }

        }


------------------- ChangeDetectionStrategy COM OBSERVABLES -------------------

detectChanges() -> detecta todas as mudanças e atualiza a view.
markForCheck() -> markForCheck instrui o Angular que essa entrada específica deve acionar a detecção
 de alterações quando estiver em mutação.


------------------- UPLOAD ANGULAR -------------------

Quando um arquivo está envolvido no upload para o back-end,
utilizamos o tipo FormData, e cadastramos os valores da seguinte forma:

upload(description: string, allowComments: boolean, file: File){

    const formData = new FormData();
    formData.append('description', description);
    formData.append('allowComments', allowComments ? 'true' : 'false');
    formData.append('imageFile', file);
    return this.http
        .post(API + '/photos/upload', formData);
}

obs: o primeiro dado do append é o nome da propriedade que meu back-end espera receber.

------------------- BASE 64 ANGULAR -------------------

Para convertermos um arquivo para base64, basta fazer da seguinte maneira:

//AO INSIRIR UM ARQUIVO, O change dispara, e envia um arquivo para o handleFile
    <input 
        #fileInput
        hidden
        formControlName="file" 
        type="file" 
        accept="image/*"
        (change)="handleFile($event.target.files[0])">

    handleFile(file: File){
        // Recebo meu arquivo normal
        this.file = file;
        const reader = new FileReader();
        // Fico esperando ele transformar pra base64, quando transformar o this.preview vai receber o valor transformado.
        reader.onload = (event: any) => this.preview = event.target.result;
        // mando transformar pra base64
        reader.readAsDataURL(file);
    }

------------------- INJECAO DE DEPENDENCIA ANGULAR -------------------

Pra que serve?
    A injecao de dependencia busca otimizar o tempo de codar / de processos,
    ao inves de vc ir lá em uma classe, dar servico = new MeuServico();
    basta ir no construtor e fazer constructor(servico: MeuServico) e pronto,
    voce ja injetou o seu servico no construtor.
Como funciona?
    Uma classe só pode ter uma Injecao de dependencia se ela tiver a diretiva Injectable, assim
    ela estara ápta a ser injetável em um construtor de uma outra classe, para fazer uso desse beneficio.

------------------- USANDO INTERPOLATION(INTERPOLAÇÃO) Para funcoes  -------------------

Aqui eu estou passando alert para getAlertClass(alert) para definir o tipo de mensagem que será exibida.
    <div *ngFor="let alert of alerts" class="{{ getAlertClass(alert) }}">
    {{ alert.message }}
    </div>


------------------- RXJS COM ANGULAR -------------------

Nesse metodo eu faco o seguinte, envio o id de uma foto para o backend, e ele vai me retornar status 201 
deu tudo certo em curtir a foto, se NAO deu tudo certo, ele me retorna 304.

então qual a sacada de usar rxjs aqui?

bom, temos um cenário aonde eu tenho que retornar um boolean se deu tudo certo na resposta,
Se der erro 304 eu tenho que retornar um Observable false, SE for outro erro eu apenas retorno o erro,
POREM se tratando do metodo POST do Http, eu tenho que retornar um Observable<boolean>, para que isso de certo.

Entao vamos la, 
    eu insiro como parametro { observe: 'response'} para receber os dados dos headers tambem e nao só do body.
    logo em seguida eu dou um pipe com MAP, e retorno true, isso é, toda vez q a requisicao der sucesso,
    ele vai retornar um Observable true (o map ja retorna um Observable por padrao, por isso só preciso retornar true),
    depois dou um pipe catchError -> esse cara que vai ser responsavel por pegar os erros vindo da requisicao,
    se for 304 eu dou um of(false) esse of é reponsavel por transformar a resposta em um observable Observable<false>,
    se o erro nao for 304, eu retorno o erro com throwError(err).


    like(photoId: number) {
        return this.http.post(
        API + '/photos/' + photoId + '/like', {}, { observe: 'response'} 
        )
        .pipe(map(res => true)) // Se na resposta vier tudo ok, retorna true.
        .pipe(catchError(err => { // como se fosse o catch do trye catch, to pegando o erro q veio da resposta
        return err.status == '304' ? of(false) : throwError(err); // se for 304 eu dou um of que retorna um Observable false
        }));
    }

------------------- Definindo Title em sua aplicação  -------------------

Para definir o title a cada pagina que voce percorre, tem duas maneiras, a primeira é bem simples,
porem em questao de manutencao não é tão interessante.

seria apenas isso que voce teria q fazer:

import { Title } from '@angular/platform-browser';

constructor(private titleService: Title)

ngOnInit(){
    this.titleService.setTitle('seuTitleAqui')
}

A segunda seria algo mais elaborado.



------------------- Routers  -------------------

//O codigo abaixo loga todos os acontecimentos(eventos) que está ocorrendo nas rotas
// Inicia de navegacao final del, guards  childs e muito mais.
constructor(private router: Router) {}
this.router.events
    .subscribe(event => console.log(event));

------------------- UPLOAD DE ARQUIVOS COM BARRA DE PROGRESSO  -------------------

O angular já nos fornece a lógica necessária para fazer isso, no codigo abaixo
estou passando a foto, e configurando os parametros necessario para receber o PROGRESSO
do upload.

deve ser feita essa configuracao: 
    { 
        observe: 'events',
        reportProgress: true
    }

service.ts 
return this.http
      .post(
        API + '/photos/upload', 
        formData,
        { 
          observe: 'events',
          reportProgress: true
        }
      );

component.ts

this.photoService
    .upload(description, allowComments, this.file)
    .pipe(finalize(() => this.router.navigate(['/user', this.userService.getUserName()])))
    .subscribe(
    (event: HttpEvent<any>) => {
        console.log(event);
        // Se for do tipo UploadProgress, é que ainda está fazendo o upload, enquanto estiver
        // fazendo o upload meu percentDone vai receber  o valor.
        if(event.type === HttpEventType.UploadProgress){
        this.percentDone = Math.round(100 * event.loaded / event.total);
        // quando for response significa que o upload já finalizou, ai eu retorno a mensagem e redireciono
        } else if (event instanceof HttpResponse) {
        this.alertService.success('Upload complete', true);
        }
    },
    (error) => {
        console.error(error);
        this.alertService.success('Upload error!', true);
    }
); 


------------------- Class Binding ANGULAR -------------------

------------------- VARIAVEIS DE TEMPLATE ANGULAR -------------------

Quando adicionada em um elemento do DOM, ela nos dará acesso ao elemento. 
Quando adicionada em um componente, nos dará acesso ao componente permitindo invocar métodos 
e acessar suas propriedades.

------------------- Class Binding ANGULAR -------------------

@HostBinding('class') elementClass = 'h-100'; -> adiciona uma classe no componente
@HostBinding('class') 'h-100': string; -> adiciona uma classe no componente

EXEMPLO -> <app-component class="h-100"></app-component>



------------------- ANGULAR COM LOIANE -------------------

------------------- DIFERENCA ENTRE TEMPLATE DRIVE / DATA DRIVEN (REATIVO) -------------------

-- TEMPLATE DRIVEN --
    com o template driven nos fazemos todas as validacoes no proprio html.
    - Formulario é criado e configurado no html
    - validacoes sao feitas no template HTML, como campo obrigatorio tamanho minino maximo regex, tudo isso temos no nosso INPUT. já no HTML.
    - Angular cria/deduz  um FormGroup no codigo HTML
    - Valores do form são submetidos com ngSubmit

-- DATA DRIVEN (REATIVO) --
    - Formulário é criado e configurado no componente.
    - Validacoes sao feitas no proprio componente
    - Angular usa o FormgGroup criado no Component
    - Form já está no componente e nao precisa do ngSubmit

------------------- TEMPLATE DRIVEN -------------------
Para gerenciar o formulário via template, devemos criar uma variavel no form, e associar a diretiva
ngForm a essa variavel, assim vamos consegui gerenciar o form atraves da variavel.

ngForm ,ngModel, ngSubmit -> todos são do módulo FormsModule

// Atraves da diretiva ngForm passada para nossa variavel form, que nós temos o controle do formulário
<form #form="ngForm" (onSubmit)="onSubmit(form)>

// Para que nosso ngForm identifique os valores ao submeter o formulário
// Devemos colocar a diretiva ngModel no campo que queremos pegar o valor
// E também devemos definir um nome para o campo, esse nome que será enviado juntamente
// com o valor para o ngForm
<input name="nome" ngModel> // { nome: 'meuValorAqui' }

-- TWO WAY DATA BINDING --
Pode ser usado ao querer já deixar preenchido os campos E atualiza-los conforme digitamos, como no exemplo abaixo
Se quisermos apenas o campo preenchido inicialmente, podemos apenas utilizar o Propertie binding
que ficaria assim: [ngModel]="usario.nome"

TS: usuario: any = {
    nome: 'Nicolas',
    email: 'nicolas@gmail.com'
}
<input name="nome" [(ngModel)]="usuario.nome"> // O valor atual será igual o valor definido no TS, no caso 'Nicolas'
<input name="email" [(ngModel)]="usuario.email"> // O valor atual será igual o valor definido no TS, no caso 'nicolas@gmail.com'

-- VALIDATIONS --

O angular trabalha com algumas classes, e essas classes
vão sendo aplicadas dependendo do estado do controle.

TABELA DE CLASSE:
Estado                            SIM                              NAO
Controle visitado               ng-touched                     ng-untouched
Valor mudou                     ng-dirty                       ng-pristine
Controle visitado               ng-touched                     ng-untouched

Deixando um campo de formulário vermelho caso tenha erro:

//todo input que estiver com a classe ng-invalid, vai ficar com a borda vermelha
//POREM Ao iniciar o formulário eles já vao ficar vermelhos, pois todos estão invalidos ainda.
// para solucionar isso vemos no proximo step
input.ng-invalid { border: 1px solid red }

// ficara vermelho somente SE estiver invalido e o campo esteja com foco
input.ng-invalid.ng-touched { border: 1px solid red }

Quando demos um log no form, vemos que temos os controles de formulário, la temos todas
as validacoes, valid, invalid, touched, untouched e etc..

Fazendo a validação:

// Para ter o controle do input, devemos bindar nossa variavel #nome com o ngModel,
// Ficando assim <input #nome="ngModel">, agora conseguimos fazer a validação a seguir
// <div *ngIf="nome.touched && nome.invalid" class="invalid-feedback"> Nome é obrigatório.<\div>
<div class="form-group">
    <label for="nome">Nome</label>
    <input type="text" name="nome" [(ngModel)]="usuario.nome" 
      id="nome" class="form-control"
      [class.is-invalid]="nome.touched && nome.invalid"
      [class.is-valid]="nome.touched && nome.valid"
      placeholder="nome"
      aria-describedby="helpId" required #nome="ngModel">
    <div *ngIf="nome.touched && nome.invalid" class="invalid-feedback">
      Nome é obrigatório.
    </div>
  </div>